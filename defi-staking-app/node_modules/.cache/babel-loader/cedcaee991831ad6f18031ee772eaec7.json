{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _defineProperty = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _toConsumableArray = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _toArray = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\n\nvar _slicedToArray = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFileModifiedMap = getFileModifiedMap;\nexports.createContext = createContext;\nexports.getContext = getContext;\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _url = _interopRequireDefault(require(\"url\"));\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _dlv = _interopRequireDefault(require(\"dlv\"));\n\nvar _postcssSelectorParser = _interopRequireDefault(require(\"postcss-selector-parser\"));\n\nvar _transformThemeValue = _interopRequireDefault(require(\"../util/transformThemeValue\"));\n\nvar _parseObjectStyles = _interopRequireDefault(require(\"../util/parseObjectStyles\"));\n\nvar _prefixSelector = _interopRequireDefault(require(\"../util/prefixSelector\"));\n\nvar _isPlainObject = _interopRequireDefault(require(\"../util/isPlainObject\"));\n\nvar _escapeClassName = _interopRequireDefault(require(\"../util/escapeClassName\"));\n\nvar _nameClass = _interopRequireWildcard(require(\"../util/nameClass\"));\n\nvar _pluginUtils = require(\"../util/pluginUtils\");\n\nvar _bigSign = _interopRequireDefault(require(\"../util/bigSign\"));\n\nvar _corePlugins = require(\"../corePlugins\");\n\nvar sharedState = _interopRequireWildcard(require(\"./sharedState\"));\n\nvar _toPath = require(\"../util/toPath\");\n\nvar _log = _interopRequireDefault(require(\"../util/log\"));\n\nvar _negateValue = _interopRequireDefault(require(\"../util/negateValue\"));\n\nvar _isValidArbitraryValue = _interopRequireDefault(require(\"../util/isValidArbitraryValue\"));\n\nvar _generateRules = require(\"./generateRules\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction prefix(context, selector) {\n  var prefix1 = context.tailwindConfig.prefix;\n  return typeof prefix1 === 'function' ? prefix1(selector) : prefix1 + selector;\n}\n\nfunction parseVariantFormatString(input) {\n  if (input.includes('{')) {\n    if (!isBalanced(input)) throw new Error(\"Your { and } are unbalanced.\");\n    return input.split(/{(.*)}/gim).flatMap(function (line) {\n      return parseVariantFormatString(line);\n    }).filter(Boolean);\n  }\n\n  return [input.trim()];\n}\n\nfunction isBalanced(input) {\n  var count = 0;\n\n  var _iterator = _createForOfIteratorHelper(input),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var char = _step.value;\n\n      if (char === '{') {\n        count++;\n      } else if (char === '}') {\n        if (--count < 0) {\n          return false // unbalanced\n          ;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return count === 0;\n}\n\nfunction insertInto(list, value) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$before = _ref.before,\n      before = _ref$before === void 0 ? [] : _ref$before;\n\n  before = [].concat(before);\n\n  if (before.length <= 0) {\n    list.push(value);\n    return;\n  }\n\n  var idx = list.length - 1;\n\n  var _iterator2 = _createForOfIteratorHelper(before),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var other = _step2.value;\n      var iidx = list.indexOf(other);\n      if (iidx === -1) continue;\n      idx = Math.min(idx, iidx);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  list.splice(idx, 0, value);\n}\n\nfunction parseStyles(styles) {\n  if (!Array.isArray(styles)) {\n    return parseStyles([styles]);\n  }\n\n  return styles.flatMap(function (style) {\n    var isNode = !Array.isArray(style) && !(0, _isPlainObject).default(style);\n    return isNode ? style : (0, _parseObjectStyles).default(style);\n  });\n}\n\nfunction getClasses(selector) {\n  var parser = (0, _postcssSelectorParser).default(function (selectors) {\n    var allClasses = [];\n    selectors.walkClasses(function (classNode) {\n      allClasses.push(classNode.value);\n    });\n    return allClasses;\n  });\n  return parser.transformSync(selector);\n}\n\nfunction extractCandidates(node) {\n  var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    containsNonOnDemandable: false\n  };\n  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var classes = []; // Handle normal rules\n\n  if (node.type === 'rule') {\n    var _iterator3 = _createForOfIteratorHelper(node.selectors),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var selector = _step3.value;\n        var classCandidates = getClasses(selector); // At least one of the selectors contains non-\"on-demandable\" candidates.\n\n        if (classCandidates.length === 0) {\n          state.containsNonOnDemandable = true;\n        }\n\n        var _iterator4 = _createForOfIteratorHelper(classCandidates),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var classCandidate = _step4.value;\n            classes.push(classCandidate);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  } else if (node.type === 'atrule') {\n    node.walkRules(function (rule) {\n      var _iterator5 = _createForOfIteratorHelper(rule.selectors.flatMap(function (selector) {\n        return getClasses(selector, state, depth + 1);\n      })),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _classCandidate = _step5.value;\n          classes.push(_classCandidate);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    });\n  }\n\n  if (depth === 0) {\n    return [state.containsNonOnDemandable || classes.length === 0, classes];\n  }\n\n  return classes;\n}\n\nfunction withIdentifiers(styles) {\n  return parseStyles(styles).flatMap(function (node) {\n    var nodeMap = new Map();\n\n    var _extractCandidates = extractCandidates(node),\n        _extractCandidates2 = _slicedToArray(_extractCandidates, 2),\n        containsNonOnDemandableSelectors = _extractCandidates2[0],\n        candidates = _extractCandidates2[1]; // If this isn't \"on-demandable\", assign it a universal candidate to always include it.\n\n\n    if (containsNonOnDemandableSelectors) {\n      candidates.unshift(sharedState.NOT_ON_DEMAND);\n    } // However, it could be that it also contains \"on-demandable\" candidates.\n    // E.g.: `span, .foo {}`, in that case it should still be possible to use\n    // `@apply foo` for example.\n\n\n    return candidates.map(function (c) {\n      if (!nodeMap.has(node)) {\n        nodeMap.set(node, node);\n      }\n\n      return [c, nodeMap.get(node)];\n    });\n  });\n}\n\nfunction buildPluginApi(tailwindConfig, context, _ref2) {\n  var variantList = _ref2.variantList,\n      variantMap = _ref2.variantMap,\n      offsets = _ref2.offsets,\n      classList = _ref2.classList;\n\n  function getConfigValue(path, defaultValue) {\n    return path ? (0, _dlv).default(tailwindConfig, path, defaultValue) : tailwindConfig;\n  }\n\n  function applyConfiguredPrefix(selector) {\n    return (0, _prefixSelector).default(tailwindConfig.prefix, selector);\n  }\n\n  function prefixIdentifier(identifier, options) {\n    if (identifier === sharedState.NOT_ON_DEMAND) {\n      return sharedState.NOT_ON_DEMAND;\n    }\n\n    if (!options.respectPrefix) {\n      return identifier;\n    }\n\n    return context.tailwindConfig.prefix + identifier;\n  }\n\n  return {\n    addVariant: function addVariant(variantName, variantFunctions) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      variantFunctions = [].concat(variantFunctions).map(function (variantFunction) {\n        if (typeof variantFunction !== 'string') {\n          // Safelist public API functions\n          return function (_ref3) {\n            var modifySelectors = _ref3.modifySelectors,\n                container = _ref3.container,\n                separator = _ref3.separator;\n            return variantFunction({\n              modifySelectors: modifySelectors,\n              container: container,\n              separator: separator\n            });\n          };\n        }\n\n        variantFunction = variantFunction.replace(/\\n+/g, '').replace(/\\s{1,}/g, ' ').trim();\n        var fns = parseVariantFormatString(variantFunction).map(function (str) {\n          if (!str.startsWith('@')) {\n            return function (_ref4) {\n              var format = _ref4.format;\n              return format(str);\n            };\n          }\n\n          var _$exec = /@(.*?) (.*)/g.exec(str),\n              _$exec2 = _slicedToArray(_$exec, 3),\n              name = _$exec2[1],\n              params = _$exec2[2];\n\n          return function (_ref5) {\n            var wrap = _ref5.wrap;\n            return wrap(_postcss.default.atRule({\n              name: name,\n              params: params\n            }));\n          };\n        }).reverse();\n        return function (api) {\n          var _iterator6 = _createForOfIteratorHelper(fns),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var fn = _step6.value;\n              fn(api);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        };\n      });\n      insertInto(variantList, variantName, options);\n      variantMap.set(variantName, variantFunctions);\n    },\n    postcss: _postcss.default,\n    prefix: applyConfiguredPrefix,\n    e: _escapeClassName.default,\n    config: getConfigValue,\n    theme: function theme(path, defaultValue) {\n      var _toPath2 = (0, _toPath).toPath(path),\n          _toPath3 = _toArray(_toPath2),\n          pathRoot = _toPath3[0],\n          subPaths = _toPath3.slice(1);\n\n      var value = getConfigValue(['theme', pathRoot].concat(_toConsumableArray(subPaths)), defaultValue);\n      return (0, _transformThemeValue).default(pathRoot)(value);\n    },\n    corePlugins: function corePlugins(path) {\n      if (Array.isArray(tailwindConfig.corePlugins)) {\n        return tailwindConfig.corePlugins.includes(path);\n      }\n\n      return getConfigValue(['corePlugins', path], true);\n    },\n    variants: function variants() {\n      // Preserved for backwards compatibility but not used in v3.0+\n      return [];\n    },\n    addUserCss: function addUserCss(userCss) {\n      var _iterator7 = _createForOfIteratorHelper(withIdentifiers(userCss)),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _step7$value = _slicedToArray(_step7.value, 2),\n              identifier = _step7$value[0],\n              rule = _step7$value[1];\n\n          var offset = offsets.user++;\n\n          if (!context.candidateRuleMap.has(identifier)) {\n            context.candidateRuleMap.set(identifier, []);\n          }\n\n          context.candidateRuleMap.get(identifier).push([{\n            sort: offset,\n            layer: 'user'\n          }, rule]);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    },\n    addBase: function addBase(base) {\n      var _iterator8 = _createForOfIteratorHelper(withIdentifiers(base)),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _step8$value = _slicedToArray(_step8.value, 2),\n              identifier = _step8$value[0],\n              rule = _step8$value[1];\n\n          var prefixedIdentifier = prefixIdentifier(identifier, {});\n          var offset = offsets.base++;\n\n          if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n            context.candidateRuleMap.set(prefixedIdentifier, []);\n          }\n\n          context.candidateRuleMap.get(prefixedIdentifier).push([{\n            sort: offset,\n            layer: 'base'\n          }, rule]);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    },\n\n    /**\n    * @param {string} group\n    * @param {Record<string, string | string[]>} declarations\n    */\n    addDefaults: function addDefaults(group, declarations) {\n      var groups = _defineProperty({}, \"@defaults \".concat(group), declarations);\n\n      var _iterator9 = _createForOfIteratorHelper(withIdentifiers(groups)),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _step9$value = _slicedToArray(_step9.value, 2),\n              identifier = _step9$value[0],\n              rule = _step9$value[1];\n\n          var prefixedIdentifier = prefixIdentifier(identifier, {});\n\n          if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n            context.candidateRuleMap.set(prefixedIdentifier, []);\n          }\n\n          context.candidateRuleMap.get(prefixedIdentifier).push([{\n            sort: offsets.base++,\n            layer: 'defaults'\n          }, rule]);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    },\n    addComponents: function addComponents(components, options) {\n      var defaultOptions = {\n        respectPrefix: true,\n        respectImportant: false\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n\n      var _iterator10 = _createForOfIteratorHelper(withIdentifiers(components)),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _step10$value = _slicedToArray(_step10.value, 2),\n              identifier = _step10$value[0],\n              rule = _step10$value[1];\n\n          var prefixedIdentifier = prefixIdentifier(identifier, options);\n          classList.add(prefixedIdentifier);\n\n          if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n            context.candidateRuleMap.set(prefixedIdentifier, []);\n          }\n\n          context.candidateRuleMap.get(prefixedIdentifier).push([{\n            sort: offsets.components++,\n            layer: 'components',\n            options: options\n          }, rule]);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    },\n    addUtilities: function addUtilities(utilities, options) {\n      var defaultOptions = {\n        respectPrefix: true,\n        respectImportant: true\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n\n      var _iterator11 = _createForOfIteratorHelper(withIdentifiers(utilities)),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var _step11$value = _slicedToArray(_step11.value, 2),\n              identifier = _step11$value[0],\n              rule = _step11$value[1];\n\n          var prefixedIdentifier = prefixIdentifier(identifier, options);\n          classList.add(prefixedIdentifier);\n\n          if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n            context.candidateRuleMap.set(prefixedIdentifier, []);\n          }\n\n          context.candidateRuleMap.get(prefixedIdentifier).push([{\n            sort: offsets.utilities++,\n            layer: 'utilities',\n            options: options\n          }, rule]);\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n    },\n    matchUtilities: function matchUtilities(utilities, options) {\n      var defaultOptions = {\n        respectPrefix: true,\n        respectImportant: true\n      };\n      options = _objectSpread({}, defaultOptions, options);\n      var offset = offsets.utilities++;\n\n      var _loop = function _loop(identifier) {\n        var prefixedIdentifier = prefixIdentifier(identifier, options);\n        var rule = utilities[identifier];\n        classList.add([prefixedIdentifier, options]);\n\n        function wrapped(modifier, _ref6) {\n          var isOnlyPlugin = _ref6.isOnlyPlugin;\n          var _options = options,\n              _options$type = _options.type,\n              type = _options$type === void 0 ? 'any' : _options$type;\n          type = [].concat(type);\n\n          var _coerceValue = (0, _pluginUtils).coerceValue(type, modifier, options, tailwindConfig),\n              _coerceValue2 = _slicedToArray(_coerceValue, 2),\n              value = _coerceValue2[0],\n              coercedType = _coerceValue2[1];\n\n          if (value === undefined) {\n            return [];\n          }\n\n          if (!type.includes(coercedType) && !isOnlyPlugin) {\n            return [];\n          }\n\n          if (!(0, _isValidArbitraryValue).default(value)) {\n            return [];\n          }\n\n          var ruleSets = [].concat(rule(value)).filter(Boolean).map(function (declaration) {\n            return _defineProperty({}, (0, _nameClass).default(identifier, modifier), declaration);\n          });\n          return ruleSets;\n        }\n\n        var withOffsets = [{\n          sort: offset,\n          layer: 'utilities',\n          options: options\n        }, wrapped];\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      };\n\n      for (var identifier in utilities) {\n        _loop(identifier);\n      }\n    },\n    matchComponents: function matchComponents(components, options) {\n      var defaultOptions = {\n        respectPrefix: true,\n        respectImportant: false\n      };\n      options = _objectSpread({}, defaultOptions, options);\n      var offset = offsets.components++;\n\n      var _loop2 = function _loop2(identifier) {\n        var prefixedIdentifier = prefixIdentifier(identifier, options);\n        var rule = components[identifier];\n        classList.add([prefixedIdentifier, options]);\n\n        function wrapped(modifier, _ref8) {\n          var isOnlyPlugin = _ref8.isOnlyPlugin;\n          var _options2 = options,\n              _options2$type = _options2.type,\n              type = _options2$type === void 0 ? 'any' : _options2$type;\n          type = [].concat(type);\n\n          var _coerceValue3 = (0, _pluginUtils).coerceValue(type, modifier, options, tailwindConfig),\n              _coerceValue4 = _slicedToArray(_coerceValue3, 2),\n              value = _coerceValue4[0],\n              coercedType = _coerceValue4[1];\n\n          if (value === undefined) {\n            return [];\n          }\n\n          if (!type.includes(coercedType)) {\n            if (isOnlyPlugin) {\n              _log.default.warn([\"Unnecessary typehint `\".concat(coercedType, \"` in `\").concat(identifier, \"-\").concat(modifier, \"`.\"), \"You can safely update it to `\".concat(identifier, \"-\").concat(modifier.replace(coercedType + ':', ''), \"`.\")]);\n            } else {\n              return [];\n            }\n          }\n\n          if (!(0, _isValidArbitraryValue).default(value)) {\n            return [];\n          }\n\n          var ruleSets = [].concat(rule(value)).filter(Boolean).map(function (declaration) {\n            return _defineProperty({}, (0, _nameClass).default(identifier, modifier), declaration);\n          });\n          return ruleSets;\n        }\n\n        var withOffsets = [{\n          sort: offset,\n          layer: 'components',\n          options: options\n        }, wrapped];\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      };\n\n      for (var identifier in components) {\n        _loop2(identifier);\n      }\n    }\n  };\n}\n\nvar fileModifiedMapCache = new WeakMap();\n\nfunction getFileModifiedMap(context) {\n  if (!fileModifiedMapCache.has(context)) {\n    fileModifiedMapCache.set(context, new Map());\n  }\n\n  return fileModifiedMapCache.get(context);\n}\n\nfunction trackModified(files, fileModifiedMap) {\n  var changed = false;\n\n  var _iterator12 = _createForOfIteratorHelper(files),\n      _step12;\n\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var file = _step12.value;\n      var ref;\n      if (!file) continue;\n\n      var parsed = _url.default.parse(file);\n\n      var pathname = parsed.hash ? parsed.href.replace(parsed.hash, '') : parsed.href;\n      pathname = parsed.search ? pathname.replace(parsed.search, '') : pathname;\n      var newModified = (ref = _fs.default.statSync(decodeURIComponent(pathname), {\n        throwIfNoEntry: false\n      })) === null || ref === void 0 ? void 0 : ref.mtimeMs;\n\n      if (!newModified) {\n        continue;\n      }\n\n      if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n        changed = true;\n      }\n\n      fileModifiedMap.set(file, newModified);\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n\n  return changed;\n}\n\nfunction extractVariantAtRules(node) {\n  node.walkAtRules(function (atRule) {\n    if (['responsive', 'variants'].includes(atRule.name)) {\n      extractVariantAtRules(atRule);\n      atRule.before(atRule.nodes);\n      atRule.remove();\n    }\n  });\n}\n\nfunction collectLayerPlugins(root) {\n  var layerPlugins = [];\n  root.each(function (node) {\n    if (node.type === 'atrule' && ['responsive', 'variants'].includes(node.name)) {\n      node.name = 'layer';\n      node.params = 'utilities';\n    }\n  }); // Walk @layer rules and treat them like plugins\n\n  root.walkAtRules('layer', function (layerRule) {\n    extractVariantAtRules(layerRule);\n\n    if (layerRule.params === 'base') {\n      var _iterator13 = _createForOfIteratorHelper(layerRule.nodes),\n          _step13;\n\n      try {\n        var _loop3 = function _loop3() {\n          var node = _step13.value;\n          layerPlugins.push(function (_ref10) {\n            var addBase = _ref10.addBase;\n            addBase(node, {\n              respectPrefix: false\n            });\n          });\n        };\n\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          _loop3();\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      layerRule.remove();\n    } else if (layerRule.params === 'components') {\n      var _iterator14 = _createForOfIteratorHelper(layerRule.nodes),\n          _step14;\n\n      try {\n        var _loop4 = function _loop4() {\n          var node = _step14.value;\n          layerPlugins.push(function (_ref11) {\n            var addComponents = _ref11.addComponents;\n            addComponents(node, {\n              respectPrefix: false\n            });\n          });\n        };\n\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          _loop4();\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      layerRule.remove();\n    } else if (layerRule.params === 'utilities') {\n      var _iterator15 = _createForOfIteratorHelper(layerRule.nodes),\n          _step15;\n\n      try {\n        var _loop5 = function _loop5() {\n          var node = _step15.value;\n          layerPlugins.push(function (_ref12) {\n            var addUtilities = _ref12.addUtilities;\n            addUtilities(node, {\n              respectPrefix: false\n            });\n          });\n        };\n\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          _loop5();\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n\n      layerRule.remove();\n    }\n  });\n  root.walkRules(function (rule) {\n    // At this point it is safe to include all the left-over css from the\n    // user's css file. This is because the `@tailwind` and `@layer` directives\n    // will already be handled and will be removed from the css tree.\n    layerPlugins.push(function (_ref13) {\n      var addUserCss = _ref13.addUserCss;\n      addUserCss(rule, {\n        respectPrefix: false\n      });\n    });\n  });\n  return layerPlugins;\n}\n\nfunction resolvePlugins(context, root) {\n  var corePluginList = Object.entries(_objectSpread({}, _corePlugins.variantPlugins, _corePlugins.corePlugins)).map(function (_ref14) {\n    var _ref15 = _slicedToArray(_ref14, 2),\n        name = _ref15[0],\n        plugin = _ref15[1];\n\n    if (!context.tailwindConfig.corePlugins.includes(name)) {\n      return null;\n    }\n\n    return plugin;\n  }).filter(Boolean);\n  var userPlugins = context.tailwindConfig.plugins.map(function (plugin) {\n    if (plugin.__isOptionsFunction) {\n      plugin = plugin();\n    }\n\n    return typeof plugin === 'function' ? plugin : plugin.handler;\n  });\n  var layerPlugins = collectLayerPlugins(root); // TODO: This is a workaround for backwards compatibility, since custom variants\n  // were historically sorted before screen/stackable variants.\n\n  var beforeVariants = [_corePlugins.variantPlugins['pseudoElementVariants'], _corePlugins.variantPlugins['pseudoClassVariants']];\n  var afterVariants = [_corePlugins.variantPlugins['directionVariants'], _corePlugins.variantPlugins['reducedMotionVariants'], _corePlugins.variantPlugins['darkVariants'], _corePlugins.variantPlugins['printVariant'], _corePlugins.variantPlugins['screenVariants'], _corePlugins.variantPlugins['orientationVariants']];\n  return [].concat(_toConsumableArray(corePluginList), beforeVariants, _toConsumableArray(userPlugins), afterVariants, _toConsumableArray(layerPlugins));\n}\n\nfunction registerPlugins(plugins, context) {\n  var variantList = [];\n  var variantMap = new Map();\n  var offsets = {\n    defaults: 0n,\n    base: 0n,\n    components: 0n,\n    utilities: 0n,\n    user: 0n\n  };\n  var classList = new Set();\n  var pluginApi = buildPluginApi(context.tailwindConfig, context, {\n    variantList: variantList,\n    variantMap: variantMap,\n    offsets: offsets,\n    classList: classList\n  });\n\n  var _iterator16 = _createForOfIteratorHelper(plugins),\n      _step16;\n\n  try {\n    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n      var plugin = _step16.value;\n\n      if (Array.isArray(plugin)) {\n        var _iterator26 = _createForOfIteratorHelper(plugin),\n            _step26;\n\n        try {\n          for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n            var pluginItem = _step26.value;\n            pluginItem(pluginApi);\n          }\n        } catch (err) {\n          _iterator26.e(err);\n        } finally {\n          _iterator26.f();\n        }\n      } else {\n        plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);\n      }\n    }\n  } catch (err) {\n    _iterator16.e(err);\n  } finally {\n    _iterator16.f();\n  }\n\n  var highestOffset = function (args) {\n    return args.reduce(function (m, e) {\n      return e > m ? e : m;\n    });\n  }([offsets.base, offsets.defaults, offsets.components, offsets.utilities, offsets.user]);\n\n  var reservedBits = BigInt(highestOffset.toString(2).length); // A number one less than the top range of the highest offset area\n  // so arbitrary properties are always sorted at the end.\n\n  context.arbitraryPropertiesSort = (1n << reservedBits << 0n) - 1n;\n  context.layerOrder = {\n    defaults: 1n << reservedBits << 0n,\n    base: 1n << reservedBits << 1n,\n    components: 1n << reservedBits << 2n,\n    utilities: 1n << reservedBits << 3n,\n    user: 1n << reservedBits << 4n\n  };\n  reservedBits += 5n;\n  var offset = 0;\n  context.variantOrder = new Map(variantList.map(function (variant, i) {\n    var variantFunctions = variantMap.get(variant).length;\n    var bits = 1n << BigInt(i + offset) << reservedBits;\n    offset += variantFunctions - 1;\n    return [variant, bits];\n  }).sort(function (_ref16, _ref17) {\n    var _ref18 = _slicedToArray(_ref16, 2),\n        a = _ref18[1];\n\n    var _ref19 = _slicedToArray(_ref17, 2),\n        z = _ref19[1];\n\n    return (0, _bigSign).default(a - z);\n  }));\n  context.minimumScreen = _toConsumableArray(context.variantOrder.values()).shift(); // Build variantMap\n\n  var _iterator17 = _createForOfIteratorHelper(variantMap.entries()),\n      _step17;\n\n  try {\n    var _loop7 = function _loop7() {\n      var _step17$value = _slicedToArray(_step17.value, 2),\n          variantName = _step17$value[0],\n          variantFunctions1 = _step17$value[1];\n\n      var sort = context.variantOrder.get(variantName);\n      context.variantMap.set(variantName, variantFunctions1.map(function (variantFunction, idx) {\n        return [sort << BigInt(idx), variantFunction];\n      }));\n    };\n\n    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n      _loop7();\n    }\n  } catch (err) {\n    _iterator17.e(err);\n  } finally {\n    _iterator17.f();\n  }\n\n  var _safelist;\n\n  var safelist = ((_safelist = context.tailwindConfig.safelist) !== null && _safelist !== void 0 ? _safelist : []).filter(Boolean);\n\n  if (safelist.length > 0) {\n    var checks = [];\n\n    var _iterator18 = _createForOfIteratorHelper(safelist),\n        _step18;\n\n    try {\n      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n        var value1 = _step18.value;\n\n        if (typeof value1 === 'string') {\n          context.changedContent.push({\n            content: value1,\n            extension: 'html'\n          });\n          continue;\n        }\n\n        if (value1 instanceof RegExp) {\n          _log.default.warn('root-regex', ['Regular expressions in `safelist` work differently in Tailwind CSS v3.0.', 'Update your `safelist` configuration to eliminate this warning.', 'https://tailwindcss.com/docs/content-configuration#safelisting-classes']);\n\n          continue;\n        }\n\n        checks.push(value1);\n      }\n    } catch (err) {\n      _iterator18.e(err);\n    } finally {\n      _iterator18.f();\n    }\n\n    if (checks.length > 0) {\n      (function () {\n        var patternMatchingCount = new Map();\n        var prefixLength = context.tailwindConfig.prefix.length;\n\n        var _iterator19 = _createForOfIteratorHelper(classList),\n            _step19;\n\n        try {\n          var _loop6 = function _loop6() {\n            var util = _step19.value;\n            var utils = Array.isArray(util) ? function () {\n              var _util = _slicedToArray(util, 2),\n                  utilName = _util[0],\n                  options = _util[1];\n\n              var ref;\n              var values = Object.keys((ref = options === null || options === void 0 ? void 0 : options.values) !== null && ref !== void 0 ? ref : {});\n              var classes = values.map(function (value) {\n                return (0, _nameClass).formatClass(utilName, value);\n              });\n\n              if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {\n                // This is the normal negated version\n                // e.g. `-inset-1` or `-tw-inset-1`\n                classes = [].concat(_toConsumableArray(classes), _toConsumableArray(classes.map(function (cls) {\n                  return '-' + cls;\n                }))); // This is the negated version *after* the prefix\n                // e.g. `tw--inset-1`\n                // The prefix is already attached to util name\n                // So we add the negative after the prefix\n\n                classes = [].concat(_toConsumableArray(classes), _toConsumableArray(classes.map(function (cls) {\n                  return cls.slice(0, prefixLength) + '-' + cls.slice(prefixLength);\n                })));\n              }\n\n              return classes;\n            }() : [util];\n\n            var _iterator21 = _createForOfIteratorHelper(utils),\n                _step21;\n\n            try {\n              for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n                var util1 = _step21.value;\n\n                var _iterator22 = _createForOfIteratorHelper(checks),\n                    _step22;\n\n                try {\n                  for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n                    var _step22$value = _step22.value,\n                        pattern = _step22$value.pattern,\n                        _step22$value$variant = _step22$value.variants,\n                        variants = _step22$value$variant === void 0 ? [] : _step22$value$variant;\n                    // RegExp with the /g flag are stateful, so let's reset the last\n                    // index pointer to reset the state.\n                    pattern.lastIndex = 0;\n\n                    if (!patternMatchingCount.has(pattern)) {\n                      patternMatchingCount.set(pattern, 0);\n                    }\n\n                    if (!pattern.test(util1)) continue;\n                    patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);\n                    context.changedContent.push({\n                      content: util1,\n                      extension: 'html'\n                    });\n\n                    var _iterator23 = _createForOfIteratorHelper(variants),\n                        _step23;\n\n                    try {\n                      for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n                        var variant = _step23.value;\n                        context.changedContent.push({\n                          content: variant + context.tailwindConfig.separator + util1,\n                          extension: 'html'\n                        });\n                      }\n                    } catch (err) {\n                      _iterator23.e(err);\n                    } finally {\n                      _iterator23.f();\n                    }\n                  }\n                } catch (err) {\n                  _iterator22.e(err);\n                } finally {\n                  _iterator22.f();\n                }\n              }\n            } catch (err) {\n              _iterator21.e(err);\n            } finally {\n              _iterator21.f();\n            }\n          };\n\n          for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n            _loop6();\n          }\n        } catch (err) {\n          _iterator19.e(err);\n        } finally {\n          _iterator19.f();\n        }\n\n        var _iterator20 = _createForOfIteratorHelper(patternMatchingCount.entries()),\n            _step20;\n\n        try {\n          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n            var _step20$value = _slicedToArray(_step20.value, 2),\n                regex = _step20$value[0],\n                count = _step20$value[1];\n\n            if (count !== 0) continue;\n\n            _log.default.warn([\"The safelist pattern `\".concat(regex, \"` doesn't match any Tailwind CSS classes.\"), 'Fix this pattern or remove it from your `safelist` configuration.', 'https://tailwindcss.com/docs/content-configuration#safelisting-classes']);\n          }\n        } catch (err) {\n          _iterator20.e(err);\n        } finally {\n          _iterator20.f();\n        }\n      })();\n    }\n  } // A list of utilities that are used by certain Tailwind CSS utilities but\n  // that don't exist on their own. This will result in them \"not existing\" and\n  // sorting could be weird since you still require them in order to make the\n  // host utitlies work properly. (Thanks Biology)\n\n\n  var parasiteUtilities = new Set([prefix(context, 'group'), prefix(context, 'peer')]);\n\n  context.getClassOrder = function getClassOrder(classes) {\n    var sortedClassNames = new Map();\n\n    var _iterator24 = _createForOfIteratorHelper((0, _generateRules).generateRules(new Set(classes), context)),\n        _step24;\n\n    try {\n      for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n        var _step24$value = _slicedToArray(_step24.value, 2),\n            sort = _step24$value[0],\n            rule = _step24$value[1];\n\n        if (sortedClassNames.has(rule.raws.tailwind.candidate)) continue;\n        sortedClassNames.set(rule.raws.tailwind.candidate, sort);\n      }\n    } catch (err) {\n      _iterator24.e(err);\n    } finally {\n      _iterator24.f();\n    }\n\n    return classes.map(function (className) {\n      var ref;\n      var order = (ref = sortedClassNames.get(className)) !== null && ref !== void 0 ? ref : null;\n\n      if (order === null && parasiteUtilities.has(className)) {\n        // This will make sure that it is at the very beginning of the\n        // `components` layer which technically means 'before any\n        // components'.\n        order = context.layerOrder.components;\n      }\n\n      return [className, order];\n    });\n  }; // Generate a list of strings for autocompletion purposes, e.g.\n  // ['uppercase', 'lowercase', ...]\n\n\n  context.getClassList = function getClassList() {\n    var output = [];\n\n    var _iterator25 = _createForOfIteratorHelper(classList),\n        _step25;\n\n    try {\n      for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n        var util = _step25.value;\n\n        if (Array.isArray(util)) {\n          var _util2 = _slicedToArray(util, 2),\n              utilName = _util2[0],\n              options = _util2[1];\n\n          var negativeClasses = [];\n          var ref;\n\n          for (var _i = 0, _Object$entries = Object.entries((ref = options === null || options === void 0 ? void 0 : options.values) !== null && ref !== void 0 ? ref : {}); _i < _Object$entries.length; _i++) {\n            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n                key = _Object$entries$_i[0],\n                value = _Object$entries$_i[1];\n\n            output.push((0, _nameClass).formatClass(utilName, key));\n\n            if ((options === null || options === void 0 ? void 0 : options.supportsNegativeValues) && (0, _negateValue).default(value)) {\n              negativeClasses.push((0, _nameClass).formatClass(utilName, \"-\".concat(key)));\n            }\n          }\n\n          output.push.apply(output, negativeClasses);\n        } else {\n          output.push(util);\n        }\n      }\n    } catch (err) {\n      _iterator25.e(err);\n    } finally {\n      _iterator25.f();\n    }\n\n    return output;\n  };\n}\n\nfunction createContext(tailwindConfig) {\n  var changedContent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _postcss.default.root();\n  var context = {\n    disposables: [],\n    ruleCache: new Set(),\n    classCache: new Map(),\n    applyClassCache: new Map(),\n    notClassCache: new Set(),\n    postCssNodeCache: new Map(),\n    candidateRuleMap: new Map(),\n    tailwindConfig: tailwindConfig,\n    changedContent: changedContent,\n    variantMap: new Map(),\n    stylesheetCache: null\n  };\n  var resolvedPlugins = resolvePlugins(context, root);\n  registerPlugins(resolvedPlugins, context);\n  return context;\n}\n\nvar contextMap = sharedState.contextMap;\nvar configContextMap = sharedState.configContextMap;\nvar contextSourcesMap = sharedState.contextSourcesMap;\n\nfunction getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n  var sourcePath = result.opts.from;\n  var isConfigFile = userConfigPath !== null;\n  sharedState.env.DEBUG && console.log('Source path:', sourcePath);\n  var existingContext;\n\n  if (isConfigFile && contextMap.has(sourcePath)) {\n    existingContext = contextMap.get(sourcePath);\n  } else if (configContextMap.has(tailwindConfigHash)) {\n    var _context = configContextMap.get(tailwindConfigHash);\n\n    contextSourcesMap.get(_context).add(sourcePath);\n    contextMap.set(sourcePath, _context);\n    existingContext = _context;\n  } // If there's already a context in the cache and we don't need to\n  // reset the context, return the cached context.\n\n\n  if (existingContext) {\n    var contextDependenciesChanged = trackModified(_toConsumableArray(contextDependencies), getFileModifiedMap(existingContext));\n\n    if (!contextDependenciesChanged) {\n      return [existingContext, false];\n    }\n  } // If this source is in the context map, get the old context.\n  // Remove this source from the context sources for the old context,\n  // and clean up that context if no one else is using it. This can be\n  // called by many processes in rapid succession, so we check for presence\n  // first because the first process to run this code will wipe it out first.\n\n\n  if (contextMap.has(sourcePath)) {\n    var oldContext = contextMap.get(sourcePath);\n\n    if (contextSourcesMap.has(oldContext)) {\n      contextSourcesMap.get(oldContext).delete(sourcePath);\n\n      if (contextSourcesMap.get(oldContext).size === 0) {\n        contextSourcesMap.delete(oldContext);\n\n        var _iterator27 = _createForOfIteratorHelper(configContextMap),\n            _step27;\n\n        try {\n          for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n            var _step27$value = _slicedToArray(_step27.value, 2),\n                _tailwindConfigHash = _step27$value[0],\n                _context2 = _step27$value[1];\n\n            if (_context2 === oldContext) {\n              configContextMap.delete(_tailwindConfigHash);\n            }\n          }\n        } catch (err) {\n          _iterator27.e(err);\n        } finally {\n          _iterator27.f();\n        }\n\n        var _iterator28 = _createForOfIteratorHelper(oldContext.disposables.splice(0)),\n            _step28;\n\n        try {\n          for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n            var disposable = _step28.value;\n            disposable(oldContext);\n          }\n        } catch (err) {\n          _iterator28.e(err);\n        } finally {\n          _iterator28.f();\n        }\n      }\n    }\n  }\n\n  sharedState.env.DEBUG && console.log('Setting up new context...');\n  var context = createContext(tailwindConfig, [], root);\n  trackModified(_toConsumableArray(contextDependencies), getFileModifiedMap(context)); // ---\n  // Update all context tracking state\n\n  configContextMap.set(tailwindConfigHash, context);\n  contextMap.set(sourcePath, context);\n\n  if (!contextSourcesMap.has(context)) {\n    contextSourcesMap.set(context, new Set());\n  }\n\n  contextSourcesMap.get(context).add(sourcePath);\n  return [context, true];\n}","map":null,"metadata":{},"sourceType":"script"}