{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils = require(\"../../utils\");\n\nvar EntryFilter = /*#__PURE__*/function () {\n  function EntryFilter(_settings, _micromatchOptions) {\n    _classCallCheck(this, EntryFilter);\n\n    this._settings = _settings;\n    this._micromatchOptions = _micromatchOptions;\n    this.index = new Map();\n  }\n\n  _createClass(EntryFilter, [{\n    key: \"getFilter\",\n    value: function getFilter(positive, negative) {\n      var _this = this;\n\n      var positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);\n      var negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);\n      return function (entry) {\n        return _this._filter(entry, positiveRe, negativeRe);\n      };\n    }\n  }, {\n    key: \"_filter\",\n    value: function _filter(entry, positiveRe, negativeRe) {\n      if (this._settings.unique && this._isDuplicateEntry(entry)) {\n        return false;\n      }\n\n      if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {\n        return false;\n      }\n\n      if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {\n        return false;\n      }\n\n      var filepath = this._settings.baseNameMatch ? entry.name : entry.path;\n      var isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);\n\n      if (this._settings.unique && isMatched) {\n        this._createIndexRecord(entry);\n      }\n\n      return isMatched;\n    }\n  }, {\n    key: \"_isDuplicateEntry\",\n    value: function _isDuplicateEntry(entry) {\n      return this.index.has(entry.path);\n    }\n  }, {\n    key: \"_createIndexRecord\",\n    value: function _createIndexRecord(entry) {\n      this.index.set(entry.path, undefined);\n    }\n  }, {\n    key: \"_onlyFileFilter\",\n    value: function _onlyFileFilter(entry) {\n      return this._settings.onlyFiles && !entry.dirent.isFile();\n    }\n  }, {\n    key: \"_onlyDirectoryFilter\",\n    value: function _onlyDirectoryFilter(entry) {\n      return this._settings.onlyDirectories && !entry.dirent.isDirectory();\n    }\n  }, {\n    key: \"_isSkippedByAbsoluteNegativePatterns\",\n    value: function _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {\n      if (!this._settings.absolute) {\n        return false;\n      }\n\n      var fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);\n      return utils.pattern.matchAny(fullpath, patternsRe);\n    }\n    /**\n     * First, just trying to apply patterns to the path.\n     * Second, trying to apply patterns to the path with final slash.\n     */\n\n  }, {\n    key: \"_isMatchToPatterns\",\n    value: function _isMatchToPatterns(entryPath, patternsRe) {\n      var filepath = utils.path.removeLeadingDotSegment(entryPath);\n      return utils.pattern.matchAny(filepath, patternsRe) || utils.pattern.matchAny(filepath + '/', patternsRe);\n    }\n  }]);\n\n  return EntryFilter;\n}();\n\nexports.default = EntryFilter;","map":null,"metadata":{},"sourceType":"script"}