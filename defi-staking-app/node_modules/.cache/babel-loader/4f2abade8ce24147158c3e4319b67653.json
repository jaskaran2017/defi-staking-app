{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _slicedToArray = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = expandApplyAtRules;\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _postcssSelectorParser = _interopRequireDefault(require(\"postcss-selector-parser\"));\n\nvar _generateRules = require(\"./generateRules\");\n\nvar _bigSign = _interopRequireDefault(require(\"../util/bigSign\"));\n\nvar _escapeClassName = _interopRequireDefault(require(\"../util/escapeClassName\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction extractClasses(node) {\n  var classes = new Set();\n\n  var container = _postcss.default.root({\n    nodes: [node.clone()]\n  });\n\n  container.walkRules(function (rule) {\n    (0, _postcssSelectorParser).default(function (selectors) {\n      selectors.walkClasses(function (classSelector) {\n        classes.add(classSelector.value);\n      });\n    }).processSync(rule.selector);\n  });\n  return Array.from(classes);\n}\n\nfunction extractBaseCandidates(candidates, separator) {\n  var baseClasses = new Set();\n\n  var _iterator = _createForOfIteratorHelper(candidates),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var candidate = _step.value;\n      baseClasses.add(candidate.split(separator).pop());\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return Array.from(baseClasses);\n}\n\nfunction prefix(context, selector) {\n  var prefix1 = context.tailwindConfig.prefix;\n  return typeof prefix1 === 'function' ? prefix1(selector) : prefix1 + selector;\n}\n\nfunction buildApplyCache(applyCandidates, context) {\n  var _iterator2 = _createForOfIteratorHelper(applyCandidates),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var candidate = _step2.value;\n\n      if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {\n        continue;\n      }\n\n      if (context.classCache.has(candidate)) {\n        context.applyClassCache.set(candidate, context.classCache.get(candidate).map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              meta = _ref2[0],\n              rule = _ref2[1];\n\n          return [meta, rule.clone()];\n        }));\n        continue;\n      }\n\n      var matches = Array.from((0, _generateRules).resolveMatches(candidate, context));\n\n      if (matches.length === 0) {\n        context.notClassCache.add(candidate);\n        continue;\n      }\n\n      context.applyClassCache.set(candidate, matches);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return context.applyClassCache;\n}\n\nfunction extractApplyCandidates(params) {\n  var candidates = params.split(/[\\s\\t\\n]+/g);\n\n  if (candidates[candidates.length - 1] === '!important') {\n    return [candidates.slice(0, -1), true];\n  }\n\n  return [candidates, false];\n}\n\nfunction processApply(root, context) {\n  var applyCandidates = new Set(); // Collect all @apply rules and candidates\n\n  var applies = [];\n  root.walkAtRules('apply', function (rule) {\n    var _extractApplyCandidat = extractApplyCandidates(rule.params),\n        _extractApplyCandidat2 = _slicedToArray(_extractApplyCandidat, 1),\n        candidates = _extractApplyCandidat2[0];\n\n    var _iterator3 = _createForOfIteratorHelper(candidates),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var util = _step3.value;\n        applyCandidates.add(util);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    applies.push(rule);\n  }); // Start the @apply process if we have rules with @apply in them\n\n  if (applies.length > 0) {\n    (function () {\n      /**\n      * When we have an apply like this:\n      *\n      * .abc {\n      *    @apply hover:font-bold;\n      * }\n      *\n      * What we essentially will do is resolve to this:\n      *\n      * .abc {\n      *    @apply .hover\\:font-bold:hover {\n      *      font-weight: 500;\n      *    }\n      * }\n      *\n      * Notice that the to-be-applied class is `.hover\\:font-bold:hover` and that the utility candidate was `hover:font-bold`.\n      * What happens in this function is that we prepend a `.` and escape the candidate.\n      * This will result in `.hover\\:font-bold`\n      * Which means that we can replace `.hover\\:font-bold` with `.abc` in `.hover\\:font-bold:hover` resulting in `.abc:hover`\n      */\n      // TODO: Should we use postcss-selector-parser for this instead?\n      var replaceSelector = function replaceSelector(selector, utilitySelectors, candidate) {\n        var needle = \".\".concat((0, _escapeClassName).default(candidate));\n        var utilitySelectorsList = utilitySelectors.split(/\\s*\\,(?![^(]*\\))\\s*/g);\n        return selector.split(/\\s*\\,(?![^(]*\\))\\s*/g).map(function (s) {\n          var replaced = [];\n\n          var _iterator4 = _createForOfIteratorHelper(utilitySelectorsList),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var utilitySelector = _step4.value;\n              var replacedSelector = utilitySelector.replace(needle, s);\n\n              if (replacedSelector === utilitySelector) {\n                continue;\n              }\n\n              replaced.push(replacedSelector);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          return replaced.join(', ');\n        }).join(', ');\n      };\n\n      // Fill up some caches!\n      var applyClassCache = buildApplyCache(applyCandidates, context);\n      var perParentApplies = new Map(); // Collect all apply candidates and their rules\n\n      var _iterator5 = _createForOfIteratorHelper(applies),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var apply = _step5.value;\n          var candidates = perParentApplies.get(apply.parent) || [];\n          perParentApplies.set(apply.parent, candidates);\n\n          var _extractApplyCandidat3 = extractApplyCandidates(apply.params),\n              _extractApplyCandidat4 = _slicedToArray(_extractApplyCandidat3, 2),\n              _applyCandidates = _extractApplyCandidat4[0],\n              important = _extractApplyCandidat4[1];\n\n          if (apply.parent.type === 'atrule') {\n            if (apply.parent.name === 'screen') {\n              (function () {\n                var screenType = apply.parent.params;\n                throw apply.error(\"@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply \".concat(_applyCandidates.map(function (c) {\n                  return \"\".concat(screenType, \":\").concat(c);\n                }).join(' '), \" instead.\"));\n              })();\n            }\n\n            throw apply.error(\"@apply is not supported within nested at-rules like @\".concat(apply.parent.name, \". You can fix this by un-nesting @\").concat(apply.parent.name, \".\"));\n          }\n\n          var _iterator8 = _createForOfIteratorHelper(_applyCandidates),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var applyCandidate = _step8.value;\n\n              if ([prefix(context, 'group'), prefix(context, 'peer')].includes(applyCandidate)) {\n                // TODO: Link to specific documentation page with error code.\n                throw apply.error(\"@apply should not be used with the '\".concat(applyCandidate, \"' utility\"));\n              }\n\n              if (!applyClassCache.has(applyCandidate)) {\n                throw apply.error(\"The `\".concat(applyCandidate, \"` class does not exist. If `\").concat(applyCandidate, \"` is a custom class, make sure it is defined within a `@layer` directive.\"));\n              }\n\n              var rules = applyClassCache.get(applyCandidate);\n              candidates.push([applyCandidate, important, rules]);\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(perParentApplies),\n          _step6;\n\n      try {\n        var _loop = function _loop() {\n          var _step6$value = _slicedToArray(_step6.value, 2),\n              parent = _step6$value[0],\n              candidates = _step6$value[1];\n\n          var siblings = [];\n\n          var _iterator9 = _createForOfIteratorHelper(candidates),\n              _step9;\n\n          try {\n            var _loop2 = function _loop2() {\n              var _step9$value = _slicedToArray(_step9.value, 3),\n                  applyCandidate = _step9$value[0],\n                  important = _step9$value[1],\n                  rules = _step9$value[2];\n\n              var _iterator10 = _createForOfIteratorHelper(rules),\n                  _step10;\n\n              try {\n                var _loop3 = function _loop3() {\n                  var _step10$value = _slicedToArray(_step10.value, 2),\n                      meta = _step10$value[0],\n                      node = _step10$value[1];\n\n                  var parentClasses = extractClasses(parent);\n                  var nodeClasses = extractClasses(node); // Add base utility classes from the @apply node to the list of\n                  // classes to check whether it intersects and therefore results in a\n                  // circular dependency or not.\n                  //\n                  // E.g.:\n                  // .foo {\n                  //   @apply hover:a; // This applies \"a\" but with a modifier\n                  // }\n                  //\n                  // We only have to do that with base classes of the `node`, not of the `parent`\n                  // E.g.:\n                  // .hover\\:foo {\n                  //   @apply bar;\n                  // }\n                  // .bar {\n                  //   @apply foo;\n                  // }\n                  //\n                  // This should not result in a circular dependency because we are\n                  // just applying `.foo` and the rule above is `.hover\\:foo` which is\n                  // unrelated. However, if we were to apply `hover:foo` then we _did_\n                  // have to include this one.\n\n                  nodeClasses = nodeClasses.concat(extractBaseCandidates(nodeClasses, context.tailwindConfig.separator));\n                  var intersects = parentClasses.some(function (selector) {\n                    return nodeClasses.includes(selector);\n                  });\n\n                  if (intersects) {\n                    throw node.error(\"You cannot `@apply` the `\".concat(applyCandidate, \"` utility here because it creates a circular dependency.\"));\n                  }\n\n                  var root = _postcss.default.root({\n                    nodes: [node.clone()]\n                  });\n\n                  var canRewriteSelector = node.type !== 'atrule' || node.type === 'atrule' && node.name !== 'keyframes';\n\n                  if (canRewriteSelector) {\n                    root.walkRules(function (rule) {\n                      // Let's imagine you have the following structure:\n                      //\n                      // .foo {\n                      //   @apply bar;\n                      // }\n                      //\n                      // @supports (a: b) {\n                      //   .bar {\n                      //     color: blue\n                      //   }\n                      //\n                      //   .something-unrelated {}\n                      // }\n                      //\n                      // In this case we want to apply `.bar` but it happens to be in\n                      // an atrule node. We clone that node instead of the nested one\n                      // because we still want that @supports rule to be there once we\n                      // applied everything.\n                      //\n                      // However it happens to be that the `.something-unrelated` is\n                      // also in that same shared @supports atrule. This is not good,\n                      // and this should not be there. The good part is that this is\n                      // a clone already and it can be safely removed. The question is\n                      // how do we know we can remove it. Basically what we can do is\n                      // match it against the applyCandidate that you want to apply. If\n                      // it doesn't match the we can safely delete it.\n                      //\n                      // If we didn't do this, then the `replaceSelector` function\n                      // would have replaced this with something that didn't exist and\n                      // therefore it removed the selector altogether. In this specific\n                      // case it would result in `{}` instead of `.something-unrelated {}`\n                      if (!extractClasses(rule).some(function (candidate) {\n                        return candidate === applyCandidate;\n                      })) {\n                        rule.remove();\n                        return;\n                      }\n\n                      rule.selector = replaceSelector(parent.selector, rule.selector, applyCandidate);\n                      rule.walkDecls(function (d) {\n                        d.important = meta.important || important;\n                      });\n                    });\n                  } // Insert it\n\n\n                  siblings.push([// Ensure that when we are sorting, that we take the layer order into account\n                  _objectSpread({}, meta, {\n                    sort: meta.sort | context.layerOrder[meta.layer]\n                  }), root.nodes[0]]);\n                };\n\n                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                  _loop3();\n                }\n              } catch (err) {\n                _iterator10.e(err);\n              } finally {\n                _iterator10.f();\n              }\n            };\n\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              _loop2();\n            } // Inject the rules, sorted, correctly\n\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n\n          var nodes = siblings.sort(function (_ref3, _ref4) {\n            var _ref5 = _slicedToArray(_ref3, 1),\n                a = _ref5[0];\n\n            var _ref6 = _slicedToArray(_ref4, 1),\n                z = _ref6[0];\n\n            return (0, _bigSign).default(a.sort - z.sort);\n          }).map(function (s) {\n            return s[1];\n          }); // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }\n\n          parent.after(nodes);\n        };\n\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      var _iterator7 = _createForOfIteratorHelper(applies),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var apply1 = _step7.value;\n\n          // If there are left-over declarations, just remove the @apply\n          if (apply1.parent.nodes.length > 1) {\n            apply1.remove();\n          } else {\n            // The node is empty, drop the full node\n            apply1.parent.remove();\n          }\n        } // Do it again, in case we have other `@apply` rules\n\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      processApply(root, context);\n    })();\n  }\n}\n\nfunction expandApplyAtRules(context) {\n  return function (root) {\n    processApply(root, context);\n  };\n}","map":null,"metadata":{},"sourceType":"script"}