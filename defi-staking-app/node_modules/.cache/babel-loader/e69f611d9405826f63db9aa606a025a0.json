{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar parser = require('postcss-selector-parser');\n\nfunction parse(str, rule) {\n  var nodes;\n  var saver = parser(function (parsed) {\n    nodes = parsed;\n  });\n\n  try {\n    saver.processSync(str);\n  } catch (e) {\n    if (str.includes(':')) {\n      throw rule ? rule.error('Missed semicolon') : e;\n    } else {\n      throw rule ? rule.error(e.message) : e;\n    }\n  }\n\n  return nodes.at(0);\n}\n\nfunction replace(nodes, parent) {\n  var replaced = false;\n  nodes.each(function (i) {\n    if (i.type === 'nesting') {\n      var clonedParent = parent.clone();\n\n      if (i.value !== '&') {\n        i.replaceWith(parse(i.value.replace('&', clonedParent.toString())));\n      } else {\n        i.replaceWith(clonedParent);\n      }\n\n      replaced = true;\n    } else if (i.nodes) {\n      if (replace(i, parent)) {\n        replaced = true;\n      }\n    }\n  });\n  return replaced;\n}\n\nfunction selectors(parent, child) {\n  var result = [];\n  parent.selectors.forEach(function (i) {\n    var parentNode = parse(i, parent);\n    child.selectors.forEach(function (j) {\n      if (j.length) {\n        var node = parse(j, child);\n        var replaced = replace(node, parentNode);\n\n        if (!replaced) {\n          node.prepend(parser.combinator({\n            value: ' '\n          }));\n          node.prepend(parentNode.clone());\n        }\n\n        result.push(node.toString());\n      }\n    });\n  });\n  return result;\n}\n\nfunction pickComment(comment, after) {\n  if (comment && comment.type === 'comment') {\n    after.after(comment);\n    return comment;\n  } else {\n    return after;\n  }\n}\n\nfunction createFnAtruleChilds(bubble) {\n  return function atruleChilds(rule, atrule, bubbling) {\n    var children = [];\n    atrule.each(function (child) {\n      if (child.type === 'comment') {\n        children.push(child);\n      } else if (child.type === 'decl') {\n        children.push(child);\n      } else if (child.type === 'rule' && bubbling) {\n        child.selectors = selectors(rule, child);\n      } else if (child.type === 'atrule') {\n        if (child.nodes && bubble[child.name]) {\n          atruleChilds(rule, child, true);\n        } else {\n          children.push(child);\n        }\n      }\n    });\n\n    if (bubbling) {\n      if (children.length) {\n        var clone = rule.clone({\n          nodes: []\n        });\n\n        var _iterator = _createForOfIteratorHelper(children),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var child = _step.value;\n            clone.append(child);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        atrule.prepend(clone);\n      }\n    }\n  };\n}\n\nfunction pickDeclarations(selector, declarations, after, Rule) {\n  var parent = new Rule({\n    selector: selector,\n    nodes: []\n  });\n\n  var _iterator2 = _createForOfIteratorHelper(declarations),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var declaration = _step2.value;\n      parent.append(declaration);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  after.after(parent);\n  return parent;\n}\n\nfunction atruleNames(defaults, custom) {\n  var list = {};\n\n  var _iterator3 = _createForOfIteratorHelper(defaults),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _i = _step3.value;\n      list[_i] = true;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  if (custom) {\n    var _iterator4 = _createForOfIteratorHelper(custom),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var i = _step4.value;\n        var name = i.replace(/^@/, '');\n        list[name] = true;\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n\n  return list;\n}\n\nmodule.exports = function () {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var bubble = atruleNames(['media', 'supports'], opts.bubble);\n  var atruleChilds = createFnAtruleChilds(bubble);\n  var unwrap = atruleNames(['document', 'font-face', 'keyframes', '-webkit-keyframes', '-moz-keyframes'], opts.unwrap);\n  var preserveEmpty = opts.preserveEmpty;\n  return {\n    postcssPlugin: 'postcss-nested',\n    Rule: function Rule(rule, _ref) {\n      var _Rule = _ref.Rule;\n      var unwrapped = false;\n      var after = rule;\n      var copyDeclarations = false;\n      var declarations = [];\n      rule.each(function (child) {\n        if (child.type === 'rule') {\n          if (declarations.length) {\n            after = pickDeclarations(rule.selector, declarations, after, _Rule);\n            declarations = [];\n          }\n\n          copyDeclarations = true;\n          unwrapped = true;\n          child.selectors = selectors(rule, child);\n          after = pickComment(child.prev(), after);\n          after.after(child);\n          after = child;\n        } else if (child.type === 'atrule') {\n          if (declarations.length) {\n            after = pickDeclarations(rule.selector, declarations, after, _Rule);\n            declarations = [];\n          }\n\n          if (child.name === 'at-root') {\n            unwrapped = true;\n            atruleChilds(rule, child, false);\n            var nodes = child.nodes;\n\n            if (child.params) {\n              nodes = new _Rule({\n                selector: child.params,\n                nodes: nodes\n              });\n            }\n\n            after.after(nodes);\n            after = nodes;\n            child.remove();\n          } else if (bubble[child.name]) {\n            copyDeclarations = true;\n            unwrapped = true;\n            atruleChilds(rule, child, true);\n            after = pickComment(child.prev(), after);\n            after.after(child);\n            after = child;\n          } else if (unwrap[child.name]) {\n            copyDeclarations = true;\n            unwrapped = true;\n            atruleChilds(rule, child, false);\n            after = pickComment(child.prev(), after);\n            after.after(child);\n            after = child;\n          } else if (copyDeclarations) {\n            declarations.push(child);\n          }\n        } else if (child.type === 'decl' && copyDeclarations) {\n          declarations.push(child);\n        }\n      });\n\n      if (declarations.length) {\n        after = pickDeclarations(rule.selector, declarations, after, _Rule);\n      }\n\n      if (unwrapped && preserveEmpty !== true) {\n        rule.raws.semicolon = true;\n        if (rule.nodes.length === 0) rule.remove();\n      }\n    }\n  };\n};\n\nmodule.exports.postcss = true;","map":null,"metadata":{},"sourceType":"script"}