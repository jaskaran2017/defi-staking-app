{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar util = require('util');\n\nvar braces = require('braces');\n\nvar picomatch = require('picomatch');\n\nvar utils = require('picomatch/lib/utils');\n\nvar isEmptyString = function isEmptyString(val) {\n  return val === '' || val === './';\n};\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} `list` List of strings to match.\n * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\n\nvar micromatch = function micromatch(list, patterns, options) {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n  var omit = new Set();\n  var keep = new Set();\n  var items = new Set();\n  var negatives = 0;\n\n  var onResult = function onResult(state) {\n    items.add(state.output);\n\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n\n  for (var i = 0; i < patterns.length; i++) {\n    var isMatch = picomatch(String(patterns[i]), _objectSpread({}, options, {\n      onResult: onResult\n    }), true);\n    var negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n\n    var _iterator = _createForOfIteratorHelper(list),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n        var matched = isMatch(item, true);\n        var match = negated ? !matched.isMatch : matched.isMatch;\n        if (!match) continue;\n\n        if (negated) {\n          omit.add(matched.output);\n        } else {\n          omit.delete(matched.output);\n          keep.add(matched.output);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  var result = negatives === patterns.length ? _toConsumableArray(items) : _toConsumableArray(keep);\n  var matches = result.filter(function (item) {\n    return !omit.has(item);\n  });\n\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(\"No matches found for \\\"\".concat(patterns.join(', '), \"\\\"\"));\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(function (p) {\n        return p.replace(/\\\\/g, '');\n      }) : patterns;\n    }\n  }\n\n  return matches;\n};\n/**\n * Backwards compatibility\n */\n\n\nmicromatch.match = micromatch;\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = function (pattern, options) {\n  return picomatch(pattern, options);\n};\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `[options]` See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.isMatch = function (str, patterns, options) {\n  return picomatch(patterns, options)(str);\n};\n/**\n * Backwards compatibility\n */\n\n\nmicromatch.any = micromatch.isMatch;\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = function (list, patterns) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  patterns = [].concat(patterns).map(String);\n  var result = new Set();\n  var items = [];\n\n  var onResult = function onResult(state) {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n\n  var matches = new Set(micromatch(list, patterns, _objectSpread({}, options, {\n    onResult: onResult\n  })));\n\n  for (var _i = 0, _items = items; _i < _items.length; _i++) {\n    var item = _items[_i];\n\n    if (!matches.has(item)) {\n      result.add(item);\n    }\n  }\n\n  return _toConsumableArray(result);\n};\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any of the patterns matches any part of `str`.\n * @api public\n */\n\n\nmicromatch.contains = function (str, pattern, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError(\"Expected a string: \\\"\".concat(util.inspect(str), \"\\\"\"));\n  }\n\n  if (Array.isArray(pattern)) {\n    return pattern.some(function (p) {\n      return micromatch.contains(str, p, options);\n    });\n  }\n\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n\n    if (str.includes(pattern) || str.startsWith('./') && str.slice(2).includes(pattern)) {\n      return true;\n    }\n  }\n\n  return micromatch.isMatch(str, pattern, _objectSpread({}, options, {\n    contains: true\n  }));\n};\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\n\nmicromatch.matchKeys = function (obj, patterns, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n\n  var keys = micromatch(Object.keys(obj), patterns, options);\n  var res = {};\n\n  var _iterator2 = _createForOfIteratorHelper(keys),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var key = _step2.value;\n      res[key] = obj[key];\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return res;\n};\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`\n * @api public\n */\n\n\nmicromatch.some = function (list, patterns, options) {\n  var items = [].concat(list);\n\n  var _iterator3 = _createForOfIteratorHelper([].concat(patterns)),\n      _step3;\n\n  try {\n    var _loop = function _loop() {\n      var pattern = _step3.value;\n      var isMatch = picomatch(String(pattern), options);\n\n      if (items.some(function (item) {\n        return isMatch(item);\n      })) {\n        return {\n          v: true\n        };\n      }\n    };\n\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _ret = _loop();\n\n      if (typeof _ret === \"object\") return _ret.v;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return false;\n};\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`\n * @api public\n */\n\n\nmicromatch.every = function (list, patterns, options) {\n  var items = [].concat(list);\n\n  var _iterator4 = _createForOfIteratorHelper([].concat(patterns)),\n      _step4;\n\n  try {\n    var _loop2 = function _loop2() {\n      var pattern = _step4.value;\n      var isMatch = picomatch(String(pattern), options);\n\n      if (!items.every(function (item) {\n        return isMatch(item);\n      })) {\n        return {\n          v: false\n        };\n      }\n    };\n\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _ret2 = _loop2();\n\n      if (typeof _ret2 === \"object\") return _ret2.v;\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return true;\n};\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\nmicromatch.all = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError(\"Expected a string: \\\"\".concat(util.inspect(str), \"\\\"\"));\n  }\n\n  return [].concat(patterns).every(function (p) {\n    return picomatch(p, options)(str);\n  });\n};\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\n\n\nmicromatch.capture = function (glob, input, options) {\n  var posix = utils.isWindows(options);\n  var regex = picomatch.makeRe(String(glob), _objectSpread({}, options, {\n    capture: true\n  }));\n  var match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n\n  if (match) {\n    return match.slice(1).map(function (v) {\n      return v === void 0 ? '' : v;\n    });\n  }\n};\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\n\nmicromatch.makeRe = function () {\n  return picomatch.makeRe.apply(picomatch, arguments);\n};\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\n\nmicromatch.scan = function () {\n  return picomatch.scan.apply(picomatch, arguments);\n};\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.parse(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\n\n\nmicromatch.parse = function (patterns, options) {\n  var res = [];\n\n  var _iterator5 = _createForOfIteratorHelper([].concat(patterns || [])),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var pattern = _step5.value;\n\n      var _iterator6 = _createForOfIteratorHelper(braces(String(pattern), options)),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var str = _step6.value;\n          res.push(picomatch.parse(str, options));\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return res;\n};\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\n\nmicromatch.braces = function (pattern, options) {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n\n  if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n    return [pattern];\n  }\n\n  return braces(pattern, options);\n};\n/**\n * Expand braces\n */\n\n\nmicromatch.braceExpand = function (pattern, options) {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, _objectSpread({}, options, {\n    expand: true\n  }));\n};\n/**\n * Expose micromatch\n */\n\n\nmodule.exports = micromatch;","map":null,"metadata":{},"sourceType":"script"}