{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _toArray = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\n\nvar _defineProperty = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _objectSpread = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _slicedToArray = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(candidatePermutations),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(resolveMatchedPlugins),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(recordCandidates),\n    _marked4 = /*#__PURE__*/_regeneratorRuntime.mark(resolveMatches);\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateRules = exports.resolveMatches = void 0;\n\nvar _postcss = _interopRequireDefault(require(\"postcss\"));\n\nvar _postcssSelectorParser = _interopRequireDefault(require(\"postcss-selector-parser\"));\n\nvar _parseObjectStyles = _interopRequireDefault(require(\"../util/parseObjectStyles\"));\n\nvar _isPlainObject = _interopRequireDefault(require(\"../util/isPlainObject\"));\n\nvar _prefixSelector = _interopRequireDefault(require(\"../util/prefixSelector\"));\n\nvar _pluginUtils = require(\"../util/pluginUtils\");\n\nvar _log = _interopRequireDefault(require(\"../util/log\"));\n\nvar sharedState = _interopRequireWildcard(require(\"./sharedState\"));\n\nvar _formatVariantSelector = require(\"../util/formatVariantSelector\");\n\nvar _nameClass = require(\"../util/nameClass\");\n\nvar _dataTypes = require(\"../util/dataTypes\");\n\nvar _isValidArbitraryValue = _interopRequireDefault(require(\"../util/isValidArbitraryValue\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nvar classNameParser = (0, _postcssSelectorParser).default(function (selectors) {\n  return selectors.first.filter(function (_ref) {\n    var type = _ref.type;\n    return type === 'class';\n  }).pop().value;\n});\n\nfunction getClassNameFromSelector(selector) {\n  return classNameParser.transformSync(selector);\n} // Generate match permutations for a class candidate, like:\n// ['ring-offset-blue', '100']\n// ['ring-offset', 'blue-100']\n// ['ring', 'offset-blue-100']\n// Example with dynamic classes:\n// ['grid-cols', '[[linename],1fr,auto]']\n// ['grid', 'cols-[[linename],1fr,auto]']\n\n\nfunction candidatePermutations(candidate) {\n  var lastIndex, dashIdx, bracketIdx, prefix, modifier;\n  return _regeneratorRuntime.wrap(function candidatePermutations$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          lastIndex = Infinity;\n\n        case 1:\n          if (!(lastIndex >= 0)) {\n            _context.next = 13;\n            break;\n          }\n\n          dashIdx = void 0;\n\n          if (lastIndex === Infinity && candidate.endsWith(']')) {\n            bracketIdx = candidate.indexOf('['); // If character before `[` isn't a dash or a slash, this isn't a dynamic class\n            // eg. string[]\n\n            dashIdx = ['-', '/'].includes(candidate[bracketIdx - 1]) ? bracketIdx - 1 : -1;\n          } else {\n            dashIdx = candidate.lastIndexOf('-', lastIndex);\n          }\n\n          if (!(dashIdx < 0)) {\n            _context.next = 6;\n            break;\n          }\n\n          return _context.abrupt(\"break\", 13);\n\n        case 6:\n          prefix = candidate.slice(0, dashIdx);\n          modifier = candidate.slice(dashIdx + 1);\n          _context.next = 10;\n          return [prefix, modifier];\n\n        case 10:\n          lastIndex = dashIdx - 1;\n          _context.next = 1;\n          break;\n\n        case 13:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nfunction applyPrefix(matches, context) {\n  if (matches.length === 0 || context.tailwindConfig.prefix === '') {\n    return matches;\n  }\n\n  var _iterator = _createForOfIteratorHelper(matches),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var match = _step.value;\n\n      var _match = _slicedToArray(match, 1),\n          meta = _match[0];\n\n      if (meta.options.respectPrefix) {\n        (function () {\n          var container = _postcss.default.root({\n            nodes: [match[1].clone()]\n          });\n\n          var classCandidate = match[1].raws.tailwind.classCandidate;\n          container.walkRules(function (r) {\n            // If this is a negative utility with a dash *before* the prefix we\n            // have to ensure that the generated selector matches the candidate\n            // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`\n            // The disconnect between candidate <-> class can cause @apply to hard crash.\n            var shouldPrependNegative = classCandidate.startsWith('-');\n            r.selector = (0, _prefixSelector).default(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);\n          });\n          match[1] = container.nodes[0];\n        })();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return matches;\n}\n\nfunction applyImportant(matches) {\n  if (matches.length === 0) {\n    return matches;\n  }\n\n  var result = [];\n\n  var _iterator2 = _createForOfIteratorHelper(matches),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n          meta = _step2$value[0],\n          rule = _step2$value[1];\n\n      var container = _postcss.default.root({\n        nodes: [rule.clone()]\n      });\n\n      container.walkRules(function (r) {\n        r.selector = (0, _pluginUtils).updateAllClasses(r.selector, function (className) {\n          return \"!\".concat(className);\n        });\n        r.walkDecls(function (d) {\n          return d.important = true;\n        });\n      });\n      result.push([_objectSpread({}, meta, {\n        important: true\n      }), container.nodes[0]]);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return result;\n} // Takes a list of rule tuples and applies a variant like `hover`, sm`,\n// whatever to it. We used to do some extra caching here to avoid generating\n// a variant of the same rule more than once, but this was never hit because\n// we cache at the entire selector level further up the tree.\n//\n// Technically you can get a cache hit if you have `hover:focus:text-center`\n// and `focus:hover:text-center` in the same project, but it doesn't feel\n// worth the complexity for that case.\n\n\nfunction applyVariant(variant, matches, context) {\n  if (matches.length === 0) {\n    return matches;\n  }\n\n  if (context.variantMap.has(variant)) {\n    var variantFunctionTuples = context.variantMap.get(variant);\n    var result = [];\n\n    var _iterator3 = _createForOfIteratorHelper(matches),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _step3$value = _slicedToArray(_step3.value, 2),\n            meta = _step3$value[0],\n            rule1 = _step3$value[1];\n\n        // Don't generate variants for user css\n        if (meta.layer === 'user') {\n          continue;\n        }\n\n        var container = _postcss.default.root({\n          nodes: [rule1.clone()]\n        });\n\n        var _iterator4 = _createForOfIteratorHelper(variantFunctionTuples),\n            _step4;\n\n        try {\n          var _loop = function _loop() {\n            var _step4$value = _slicedToArray(_step4.value, 2),\n                variantSort = _step4$value[0],\n                variantFunction = _step4$value[1];\n\n            var clone = container.clone();\n            var collectedFormats = [];\n            var originals = new Map();\n\n            function prepareBackup() {\n              if (originals.size > 0) return; // Already prepared, chicken out\n\n              clone.walkRules(function (rule) {\n                return originals.set(rule, rule.selector);\n              });\n            }\n\n            function modifySelectors(modifierFunction) {\n              prepareBackup();\n              clone.each(function (rule) {\n                if (rule.type !== 'rule') {\n                  return;\n                }\n\n                rule.selectors = rule.selectors.map(function (selector) {\n                  return modifierFunction({\n                    get className() {\n                      return getClassNameFromSelector(selector);\n                    },\n\n                    selector: selector\n                  });\n                });\n              });\n              return clone;\n            }\n\n            var ruleWithVariant = variantFunction({\n              // Public API\n              get container() {\n                prepareBackup();\n                return clone;\n              },\n\n              separator: context.tailwindConfig.separator,\n              modifySelectors: modifySelectors,\n              // Private API for now\n              wrap: function wrap(wrapper) {\n                var nodes = clone.nodes;\n                clone.removeAll();\n                wrapper.append(nodes);\n                clone.append(wrapper);\n              },\n              format: function format(selectorFormat) {\n                collectedFormats.push(selectorFormat);\n              }\n            });\n\n            if (typeof ruleWithVariant === 'string') {\n              collectedFormats.push(ruleWithVariant);\n            }\n\n            if (ruleWithVariant === null) {\n              return \"continue\";\n            } // We filled the `originals`, therefore we assume that somebody touched\n            // `container` or `modifySelectors`. Let's see if they did, so that we\n            // can restore the selectors, and collect the format strings.\n\n\n            if (originals.size > 0) {\n              clone.walkRules(function (rule) {\n                if (!originals.has(rule)) return;\n                var before = originals.get(rule);\n                if (before === rule.selector) return; // No mutation happened\n\n                var modified = rule.selector; // Rebuild the base selector, this is what plugin authors would do\n                // as well. E.g.: `${variant}${separator}${className}`.\n                // However, plugin authors probably also prepend or append certain\n                // classes, pseudos, ids, ...\n\n                var rebuiltBase = (0, _postcssSelectorParser).default(function (selectors) {\n                  selectors.walkClasses(function (classNode) {\n                    classNode.value = \"\".concat(variant).concat(context.tailwindConfig.separator).concat(classNode.value);\n                  });\n                }).processSync(before); // Now that we know the original selector, the new selector, and\n                // the rebuild part in between, we can replace the part that plugin\n                // authors need to rebuild with `&`, and eventually store it in the\n                // collectedFormats. Similar to what `format('...')` would do.\n                //\n                // E.g.:\n                //                   variant: foo\n                //                  selector: .markdown > p\n                //      modified (by plugin): .foo .foo\\\\:markdown > p\n                //    rebuiltBase (internal): .foo\\\\:markdown > p\n                //                    format: .foo &\n\n                collectedFormats.push(modified.replace(rebuiltBase, '&'));\n                rule.selector = before;\n              });\n            } // This tracks the originating layer for the variant\n            // For example:\n            // .sm:underline {} is a variant of something in the utilities layer\n            // .sm:container {} is a variant of the container component\n\n\n            clone.nodes[0].raws.tailwind = _objectSpread({}, clone.nodes[0].raws.tailwind, {\n              parentLayer: meta.layer\n            });\n            var withOffset = [_objectSpread({}, meta, {\n              sort: variantSort | meta.sort,\n              collectedFormats: ((_collectedFormats = meta.collectedFormats) !== null && _collectedFormats !== void 0 ? _collectedFormats : []).concat(collectedFormats)\n            }), clone.nodes[0]];\n            result.push(withOffset);\n          };\n\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _collectedFormats;\n\n            var _ret = _loop();\n\n            if (_ret === \"continue\") continue;\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return result;\n  }\n\n  return [];\n}\n\nfunction parseRules(rule, cache) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  // PostCSS node\n  if (!(0, _isPlainObject).default(rule) && !Array.isArray(rule)) {\n    return [[rule], options];\n  } // Tuple\n\n\n  if (Array.isArray(rule)) {\n    return parseRules(rule[0], cache, rule[1]);\n  } // Simple object\n\n\n  if (!cache.has(rule)) {\n    cache.set(rule, (0, _parseObjectStyles).default(rule));\n  }\n\n  return [cache.get(rule), options];\n}\n\nvar IS_VALID_PROPERTY_NAME = /^[a-z_-]/;\n\nfunction isValidPropName(name) {\n  return IS_VALID_PROPERTY_NAME.test(name);\n}\n/**\n * @param {string} declaration\n * @returns {boolean}\n */\n\n\nfunction looksLikeUri(declaration) {\n  // Quick bailout for obvious non-urls\n  // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem\n  if (!declaration.includes('://')) {\n    return false;\n  }\n\n  try {\n    var url = new URL(declaration);\n    return url.scheme !== '' && url.host !== '';\n  } catch (err) {\n    // Definitely not a valid url\n    return false;\n  }\n}\n\nfunction isParsableCssValue(property, value) {\n  // We don't want to to treat [https://example.com] as a custom property\n  // Even though, according to the CSS grammar, it's a totally valid CSS declaration\n  // So we short-circuit here by checking if the custom property looks like a url\n  if (looksLikeUri(\"\".concat(property, \":\").concat(value))) {\n    return false;\n  }\n\n  try {\n    _postcss.default.parse(\"a{\".concat(property, \":\").concat(value, \"}\")).toResult();\n\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction extractArbitraryProperty(classCandidate, context) {\n  var ref;\n\n  var _ref2 = (ref = classCandidate.match(/^\\[([a-zA-Z0-9-_]+):(\\S+)\\]$/)) !== null && ref !== void 0 ? ref : [],\n      _ref3 = _slicedToArray(_ref2, 3),\n      property = _ref3[1],\n      value = _ref3[2];\n\n  if (value === undefined) {\n    return null;\n  }\n\n  if (!isValidPropName(property)) {\n    return null;\n  }\n\n  if (!(0, _isValidArbitraryValue).default(value)) {\n    return null;\n  }\n\n  var normalized = (0, _dataTypes).normalize(value);\n\n  if (!isParsableCssValue(property, normalized)) {\n    return null;\n  }\n\n  return [[{\n    sort: context.arbitraryPropertiesSort,\n    layer: 'utilities'\n  }, function () {\n    return _defineProperty({}, (0, _nameClass).asClass(classCandidate), _defineProperty({}, property, normalized));\n  }]];\n}\n\nfunction resolveMatchedPlugins(classCandidate, context) {\n  var candidatePrefix, negative, twConfigPrefix, twConfigPrefixLen, _iterator5, _step5, _step5$value, prefix, modifier;\n\n  return _regeneratorRuntime.wrap(function resolveMatchedPlugins$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          if (!context.candidateRuleMap.has(classCandidate)) {\n            _context3.next = 3;\n            break;\n          }\n\n          _context3.next = 3;\n          return [context.candidateRuleMap.get(classCandidate), 'DEFAULT'];\n\n        case 3:\n          return _context3.delegateYield( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(arbitraryPropertyRule) {\n            return _regeneratorRuntime.wrap(function _callee$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    if (!(arbitraryPropertyRule !== null)) {\n                      _context2.next = 3;\n                      break;\n                    }\n\n                    _context2.next = 3;\n                    return [arbitraryPropertyRule, 'DEFAULT'];\n\n                  case 3:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee);\n          })(extractArbitraryProperty(classCandidate, context)), \"t0\", 4);\n\n        case 4:\n          candidatePrefix = classCandidate;\n          negative = false;\n          twConfigPrefix = context.tailwindConfig.prefix;\n          twConfigPrefixLen = twConfigPrefix.length;\n\n          if (candidatePrefix[twConfigPrefixLen] === '-') {\n            negative = true;\n            candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);\n          }\n\n          if (!(negative && context.candidateRuleMap.has(candidatePrefix))) {\n            _context3.next = 12;\n            break;\n          }\n\n          _context3.next = 12;\n          return [context.candidateRuleMap.get(candidatePrefix), '-DEFAULT'];\n\n        case 12:\n          _iterator5 = _createForOfIteratorHelper(candidatePermutations(candidatePrefix));\n          _context3.prev = 13;\n\n          _iterator5.s();\n\n        case 15:\n          if ((_step5 = _iterator5.n()).done) {\n            _context3.next = 22;\n            break;\n          }\n\n          _step5$value = _slicedToArray(_step5.value, 2), prefix = _step5$value[0], modifier = _step5$value[1];\n\n          if (!context.candidateRuleMap.has(prefix)) {\n            _context3.next = 20;\n            break;\n          }\n\n          _context3.next = 20;\n          return [context.candidateRuleMap.get(prefix), negative ? \"-\".concat(modifier) : modifier];\n\n        case 20:\n          _context3.next = 15;\n          break;\n\n        case 22:\n          _context3.next = 27;\n          break;\n\n        case 24:\n          _context3.prev = 24;\n          _context3.t1 = _context3[\"catch\"](13);\n\n          _iterator5.e(_context3.t1);\n\n        case 27:\n          _context3.prev = 27;\n\n          _iterator5.f();\n\n          return _context3.finish(27);\n\n        case 30:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked2, null, [[13, 24, 27, 30]]);\n}\n\nfunction splitWithSeparator(input, separator) {\n  if (input === sharedState.NOT_ON_DEMAND) {\n    return [sharedState.NOT_ON_DEMAND];\n  }\n\n  return input.split(new RegExp(\"\\\\\".concat(separator, \"(?![^[]*\\\\])\"), 'g'));\n}\n\nfunction recordCandidates(matches, classCandidate) {\n  var _iterator6, _step6, match;\n\n  return _regeneratorRuntime.wrap(function recordCandidates$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          _iterator6 = _createForOfIteratorHelper(matches);\n          _context4.prev = 1;\n\n          _iterator6.s();\n\n        case 3:\n          if ((_step6 = _iterator6.n()).done) {\n            _context4.next = 10;\n            break;\n          }\n\n          match = _step6.value;\n          match[1].raws.tailwind = _objectSpread({}, match[1].raws.tailwind, {\n            classCandidate: classCandidate\n          });\n          _context4.next = 8;\n          return match;\n\n        case 8:\n          _context4.next = 3;\n          break;\n\n        case 10:\n          _context4.next = 15;\n          break;\n\n        case 12:\n          _context4.prev = 12;\n          _context4.t0 = _context4[\"catch\"](1);\n\n          _iterator6.e(_context4.t0);\n\n        case 15:\n          _context4.prev = 15;\n\n          _iterator6.f();\n\n          return _context4.finish(15);\n\n        case 18:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked3, null, [[1, 12, 15, 18]]);\n}\n\nfunction resolveMatches(candidate, context) {\n  var separator, _splitWithSeparator$r, _splitWithSeparator$r2, classCandidate, variants, important, _iterator7, _step7, _loop2, ref, ref1, _ret2;\n\n  return _regeneratorRuntime.wrap(function resolveMatches$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          separator = context.tailwindConfig.separator;\n          _splitWithSeparator$r = splitWithSeparator(candidate, separator).reverse(), _splitWithSeparator$r2 = _toArray(_splitWithSeparator$r), classCandidate = _splitWithSeparator$r2[0], variants = _splitWithSeparator$r2.slice(1);\n          important = false;\n\n          if (classCandidate.startsWith('!')) {\n            important = true;\n            classCandidate = classCandidate.slice(1);\n          } // TODO: Reintroduce this in ways that doesn't break on false positives\n          // function sortAgainst(toSort, against) {\n          //   return toSort.slice().sort((a, z) => {\n          //     return bigSign(against.get(a)[0] - against.get(z)[0])\n          //   })\n          // }\n          // let sorted = sortAgainst(variants, context.variantMap)\n          // if (sorted.toString() !== variants.toString()) {\n          //   let corrected = sorted.reverse().concat(classCandidate).join(':')\n          //   throw new Error(`Class ${candidate} should be written as ${corrected}`)\n          // }\n\n\n          _iterator7 = _createForOfIteratorHelper(resolveMatchedPlugins(classCandidate, context));\n          _context6.prev = 5;\n          _loop2 = /*#__PURE__*/_regeneratorRuntime.mark(function _loop2() {\n            var matchedPlugins, matches, typesByMatches, _matchedPlugins, plugins, modifier, isOnlyPlugin, _iterator8, _step8, _step8$value, sort, plugin, matchesPerPlugin, _iterator16, _step16, ruleSet, _parseRules, _parseRules2, _rules, options, _iterator17, _step17, rule, _ruleSet, _parseRules3, _parseRules4, _rules2, _options, _iterator18, _step18, _rule, typesPerPlugin, _iterator9, _step9, pluginTypes, _iterator11, _step11, type, removeFromOwnGroup, _iterator12, _step12, otherGroup, messages, _iterator10, _step10, _step10$value, idx, group, _iterator13, _step13, _type, rules, _iterator14, _step14, variant, _iterator15, _step15, match1;\n\n            return _regeneratorRuntime.wrap(function _loop2$(_context5) {\n              while (1) {\n                switch (_context5.prev = _context5.next) {\n                  case 0:\n                    matchedPlugins = _step7.value;\n                    matches = [];\n                    typesByMatches = new Map();\n                    _matchedPlugins = _slicedToArray(matchedPlugins, 2), plugins = _matchedPlugins[0], modifier = _matchedPlugins[1];\n                    isOnlyPlugin = plugins.length === 1;\n                    _iterator8 = _createForOfIteratorHelper(plugins);\n\n                    try {\n                      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                        _step8$value = _slicedToArray(_step8.value, 2), sort = _step8$value[0], plugin = _step8$value[1];\n                        matchesPerPlugin = [];\n\n                        if (typeof plugin === 'function') {\n                          _iterator16 = _createForOfIteratorHelper([].concat(plugin(modifier, {\n                            isOnlyPlugin: isOnlyPlugin\n                          })));\n\n                          try {\n                            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                              ruleSet = _step16.value;\n                              _parseRules = parseRules(ruleSet, context.postCssNodeCache), _parseRules2 = _slicedToArray(_parseRules, 2), _rules = _parseRules2[0], options = _parseRules2[1];\n                              _iterator17 = _createForOfIteratorHelper(_rules);\n\n                              try {\n                                for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                                  rule = _step17.value;\n                                  matchesPerPlugin.push([_objectSpread({}, sort, {\n                                    options: _objectSpread({}, sort.options, options)\n                                  }), rule]);\n                                }\n                              } catch (err) {\n                                _iterator17.e(err);\n                              } finally {\n                                _iterator17.f();\n                              }\n                            }\n                          } catch (err) {\n                            _iterator16.e(err);\n                          } finally {\n                            _iterator16.f();\n                          }\n                        } else if (modifier === 'DEFAULT' || modifier === '-DEFAULT') {\n                          _ruleSet = plugin;\n                          _parseRules3 = parseRules(_ruleSet, context.postCssNodeCache), _parseRules4 = _slicedToArray(_parseRules3, 2), _rules2 = _parseRules4[0], _options = _parseRules4[1];\n                          _iterator18 = _createForOfIteratorHelper(_rules2);\n\n                          try {\n                            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                              _rule = _step18.value;\n                              matchesPerPlugin.push([_objectSpread({}, sort, {\n                                options: _objectSpread({}, sort.options, _options)\n                              }), _rule]);\n                            }\n                          } catch (err) {\n                            _iterator18.e(err);\n                          } finally {\n                            _iterator18.f();\n                          }\n                        }\n\n                        if (matchesPerPlugin.length > 0) {\n                          typesByMatches.set(matchesPerPlugin, (ref = sort.options) === null || ref === void 0 ? void 0 : ref.type);\n                          matches.push(matchesPerPlugin);\n                        }\n                      } // Only keep the result of the very first plugin if we are dealing with\n                      // arbitrary values, to protect against ambiguity.\n\n                    } catch (err) {\n                      _iterator8.e(err);\n                    } finally {\n                      _iterator8.f();\n                    }\n\n                    if (!(isArbitraryValue(modifier) && matches.length > 1)) {\n                      _context5.next = 95;\n                      break;\n                    }\n\n                    typesPerPlugin = matches.map(function (match) {\n                      return new Set(_toConsumableArray((ref1 = typesByMatches.get(match)) !== null && ref1 !== void 0 ? ref1 : []));\n                    }); // Remove duplicates, so that we can detect proper unique types for each plugin.\n\n                    _iterator9 = _createForOfIteratorHelper(typesPerPlugin);\n                    _context5.prev = 10;\n\n                    _iterator9.s();\n\n                  case 12:\n                    if ((_step9 = _iterator9.n()).done) {\n                      _context5.next = 51;\n                      break;\n                    }\n\n                    pluginTypes = _step9.value;\n                    _iterator11 = _createForOfIteratorHelper(pluginTypes);\n                    _context5.prev = 15;\n\n                    _iterator11.s();\n\n                  case 17:\n                    if ((_step11 = _iterator11.n()).done) {\n                      _context5.next = 41;\n                      break;\n                    }\n\n                    type = _step11.value;\n                    removeFromOwnGroup = false;\n                    _iterator12 = _createForOfIteratorHelper(typesPerPlugin);\n                    _context5.prev = 21;\n\n                    _iterator12.s();\n\n                  case 23:\n                    if ((_step12 = _iterator12.n()).done) {\n                      _context5.next = 30;\n                      break;\n                    }\n\n                    otherGroup = _step12.value;\n\n                    if (!(pluginTypes === otherGroup)) {\n                      _context5.next = 27;\n                      break;\n                    }\n\n                    return _context5.abrupt(\"continue\", 28);\n\n                  case 27:\n                    if (otherGroup.has(type)) {\n                      otherGroup.delete(type);\n                      removeFromOwnGroup = true;\n                    }\n\n                  case 28:\n                    _context5.next = 23;\n                    break;\n\n                  case 30:\n                    _context5.next = 35;\n                    break;\n\n                  case 32:\n                    _context5.prev = 32;\n                    _context5.t0 = _context5[\"catch\"](21);\n\n                    _iterator12.e(_context5.t0);\n\n                  case 35:\n                    _context5.prev = 35;\n\n                    _iterator12.f();\n\n                    return _context5.finish(35);\n\n                  case 38:\n                    if (removeFromOwnGroup) pluginTypes.delete(type);\n\n                  case 39:\n                    _context5.next = 17;\n                    break;\n\n                  case 41:\n                    _context5.next = 46;\n                    break;\n\n                  case 43:\n                    _context5.prev = 43;\n                    _context5.t1 = _context5[\"catch\"](15);\n\n                    _iterator11.e(_context5.t1);\n\n                  case 46:\n                    _context5.prev = 46;\n\n                    _iterator11.f();\n\n                    return _context5.finish(46);\n\n                  case 49:\n                    _context5.next = 12;\n                    break;\n\n                  case 51:\n                    _context5.next = 56;\n                    break;\n\n                  case 53:\n                    _context5.prev = 53;\n                    _context5.t2 = _context5[\"catch\"](10);\n\n                    _iterator9.e(_context5.t2);\n\n                  case 56:\n                    _context5.prev = 56;\n\n                    _iterator9.f();\n\n                    return _context5.finish(56);\n\n                  case 59:\n                    messages = [];\n                    _iterator10 = _createForOfIteratorHelper(typesPerPlugin.entries());\n                    _context5.prev = 61;\n\n                    _iterator10.s();\n\n                  case 63:\n                    if ((_step10 = _iterator10.n()).done) {\n                      _context5.next = 85;\n                      break;\n                    }\n\n                    _step10$value = _slicedToArray(_step10.value, 2), idx = _step10$value[0], group = _step10$value[1];\n                    _iterator13 = _createForOfIteratorHelper(group);\n                    _context5.prev = 66;\n\n                    _iterator13.s();\n\n                  case 68:\n                    if ((_step13 = _iterator13.n()).done) {\n                      _context5.next = 75;\n                      break;\n                    }\n\n                    _type = _step13.value;\n                    rules = matches[idx].map(function (_ref5) {\n                      var _ref6 = _slicedToArray(_ref5, 2),\n                          rule = _ref6[1];\n\n                      return rule;\n                    }).flat().map(function (rule) {\n                      return rule.toString().split('\\n').slice(1, -1) // Remove selector and closing '}'\n                      .map(function (line) {\n                        return line.trim();\n                      }).map(function (x) {\n                        return \"      \".concat(x);\n                      }) // Re-indent\n                      .join('\\n');\n                    }).join('\\n\\n');\n                    messages.push(\"  Use `\".concat(candidate.replace('[', \"[\".concat(_type, \":\")), \"` for `\").concat(rules.trim(), \"`\"));\n                    return _context5.abrupt(\"break\", 75);\n\n                  case 73:\n                    _context5.next = 68;\n                    break;\n\n                  case 75:\n                    _context5.next = 80;\n                    break;\n\n                  case 77:\n                    _context5.prev = 77;\n                    _context5.t3 = _context5[\"catch\"](66);\n\n                    _iterator13.e(_context5.t3);\n\n                  case 80:\n                    _context5.prev = 80;\n\n                    _iterator13.f();\n\n                    return _context5.finish(80);\n\n                  case 83:\n                    _context5.next = 63;\n                    break;\n\n                  case 85:\n                    _context5.next = 90;\n                    break;\n\n                  case 87:\n                    _context5.prev = 87;\n                    _context5.t4 = _context5[\"catch\"](61);\n\n                    _iterator10.e(_context5.t4);\n\n                  case 90:\n                    _context5.prev = 90;\n\n                    _iterator10.f();\n\n                    return _context5.finish(90);\n\n                  case 93:\n                    _log.default.warn([\"The class `\".concat(candidate, \"` is ambiguous and matches multiple utilities.\")].concat(messages, [\"If this is content and not a class, replace it with `\".concat(candidate.replace('[', '&lsqb;').replace(']', '&rsqb;'), \"` to silence this warning.\")]));\n\n                    return _context5.abrupt(\"return\", \"continue\");\n\n                  case 95:\n                    matches = matches.flat();\n                    matches = Array.from(recordCandidates(matches, classCandidate));\n                    matches = applyPrefix(matches, context);\n\n                    if (important) {\n                      matches = applyImportant(matches, context);\n                    }\n\n                    _iterator14 = _createForOfIteratorHelper(variants);\n\n                    try {\n                      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                        variant = _step14.value;\n                        matches = applyVariant(variant, matches, context);\n                      }\n                    } catch (err) {\n                      _iterator14.e(err);\n                    } finally {\n                      _iterator14.f();\n                    }\n\n                    _iterator15 = _createForOfIteratorHelper(matches);\n                    _context5.prev = 102;\n\n                    _iterator15.s();\n\n                  case 104:\n                    if ((_step15 = _iterator15.n()).done) {\n                      _context5.next = 112;\n                      break;\n                    }\n\n                    match1 = _step15.value;\n                    match1[1].raws.tailwind = _objectSpread({}, match1[1].raws.tailwind, {\n                      candidate: candidate\n                    }); // Apply final format selector\n\n                    if (match1[0].collectedFormats) {\n                      (function () {\n                        var _ref7;\n\n                        var finalFormat = (_ref7 = (0, _formatVariantSelector)).formatVariantSelector.apply(_ref7, ['&'].concat(_toConsumableArray(match1[0].collectedFormats)));\n\n                        var container = _postcss.default.root({\n                          nodes: [match1[1].clone()]\n                        });\n\n                        container.walkRules(function (rule) {\n                          if (inKeyframes(rule)) return;\n                          rule.selector = (0, _formatVariantSelector).finalizeSelector(finalFormat, {\n                            selector: rule.selector,\n                            candidate: candidate,\n                            context: context\n                          });\n                        });\n                        match1[1] = container.nodes[0];\n                      })();\n                    }\n\n                    _context5.next = 110;\n                    return match1;\n\n                  case 110:\n                    _context5.next = 104;\n                    break;\n\n                  case 112:\n                    _context5.next = 117;\n                    break;\n\n                  case 114:\n                    _context5.prev = 114;\n                    _context5.t5 = _context5[\"catch\"](102);\n\n                    _iterator15.e(_context5.t5);\n\n                  case 117:\n                    _context5.prev = 117;\n\n                    _iterator15.f();\n\n                    return _context5.finish(117);\n\n                  case 120:\n                  case \"end\":\n                    return _context5.stop();\n                }\n              }\n            }, _loop2, null, [[10, 53, 56, 59], [15, 43, 46, 49], [21, 32, 35, 38], [61, 87, 90, 93], [66, 77, 80, 83], [102, 114, 117, 120]]);\n          });\n\n          _iterator7.s();\n\n        case 8:\n          if ((_step7 = _iterator7.n()).done) {\n            _context6.next = 15;\n            break;\n          }\n\n          return _context6.delegateYield(_loop2(), \"t0\", 10);\n\n        case 10:\n          _ret2 = _context6.t0;\n\n          if (!(_ret2 === \"continue\")) {\n            _context6.next = 13;\n            break;\n          }\n\n          return _context6.abrupt(\"continue\", 13);\n\n        case 13:\n          _context6.next = 8;\n          break;\n\n        case 15:\n          _context6.next = 20;\n          break;\n\n        case 17:\n          _context6.prev = 17;\n          _context6.t1 = _context6[\"catch\"](5);\n\n          _iterator7.e(_context6.t1);\n\n        case 20:\n          _context6.prev = 20;\n\n          _iterator7.f();\n\n          return _context6.finish(20);\n\n        case 23:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, _marked4, null, [[5, 17, 20, 23]]);\n}\n\nfunction inKeyframes(rule) {\n  return rule.parent && rule.parent.type === 'atrule' && rule.parent.name === 'keyframes';\n}\n\nfunction generateRules(candidates, context) {\n  var allRules = [];\n\n  var _iterator19 = _createForOfIteratorHelper(candidates),\n      _step19;\n\n  try {\n    for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n      var candidate = _step19.value;\n\n      if (context.notClassCache.has(candidate)) {\n        continue;\n      }\n\n      if (context.classCache.has(candidate)) {\n        allRules.push(context.classCache.get(candidate));\n        continue;\n      }\n\n      var matches = Array.from(resolveMatches(candidate, context));\n\n      if (matches.length === 0) {\n        context.notClassCache.add(candidate);\n        continue;\n      }\n\n      context.classCache.set(candidate, matches);\n      allRules.push(matches);\n    } // Strategy based on `tailwindConfig.important`\n\n  } catch (err) {\n    _iterator19.e(err);\n  } finally {\n    _iterator19.f();\n  }\n\n  var strategy = function (important) {\n    if (important === true) {\n      return function (rule) {\n        rule.walkDecls(function (d) {\n          if (d.parent.type === 'rule' && !inKeyframes(d.parent)) {\n            d.important = true;\n          }\n        });\n      };\n    }\n\n    if (typeof important === 'string') {\n      return function (rule) {\n        rule.selectors = rule.selectors.map(function (selector) {\n          return \"\".concat(important, \" \").concat(selector);\n        });\n      };\n    }\n  }(context.tailwindConfig.important);\n\n  return allRules.flat(1).map(function (_ref8) {\n    var _ref9 = _slicedToArray(_ref8, 2),\n        _ref9$ = _ref9[0],\n        sort = _ref9$.sort,\n        layer = _ref9$.layer,\n        options = _ref9$.options,\n        rule = _ref9[1];\n\n    if (options.respectImportant) {\n      if (strategy) {\n        var container = _postcss.default.root({\n          nodes: [rule.clone()]\n        });\n\n        container.walkRules(function (r) {\n          if (inKeyframes(r)) {\n            return;\n          }\n\n          strategy(r);\n        });\n        rule = container.nodes[0];\n      }\n    }\n\n    return [sort | context.layerOrder[layer], rule];\n  });\n}\n\nfunction isArbitraryValue(input) {\n  return input.startsWith('[') && input.endsWith(']');\n}\n\nexports.resolveMatches = resolveMatches;\nexports.generateRules = generateRules;","map":null,"metadata":{},"sourceType":"script"}