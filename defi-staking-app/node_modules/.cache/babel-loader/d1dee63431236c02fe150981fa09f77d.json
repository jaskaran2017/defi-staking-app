{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/apple/Desktop/remix_udamy/udamy_project/defi-staking-app-starter/defi-staking-app-starter/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar taskManager = require(\"./managers/tasks\");\n\nvar patternManager = require(\"./managers/patterns\");\n\nvar async_1 = require(\"./providers/async\");\n\nvar stream_1 = require(\"./providers/stream\");\n\nvar sync_1 = require(\"./providers/sync\");\n\nvar settings_1 = require(\"./settings\");\n\nvar utils = require(\"./utils\");\n\nfunction FastGlob(_x, _x2) {\n  return _FastGlob.apply(this, arguments);\n} // https://github.com/typescript-eslint/typescript-eslint/issues/60\n// eslint-disable-next-line no-redeclare\n\n\nfunction _FastGlob() {\n  _FastGlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source, options) {\n    var works, result;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            assertPatternsInput(source);\n            works = getWorks(source, async_1.default, options);\n            _context.next = 4;\n            return Promise.all(works);\n\n          case 4:\n            result = _context.sent;\n            return _context.abrupt(\"return\", utils.array.flatten(result));\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _FastGlob.apply(this, arguments);\n}\n\n(function (FastGlob) {\n  function sync(source, options) {\n    assertPatternsInput(source);\n    var works = getWorks(source, sync_1.default, options);\n    return utils.array.flatten(works);\n  }\n\n  FastGlob.sync = sync;\n\n  function stream(source, options) {\n    assertPatternsInput(source);\n    var works = getWorks(source, stream_1.default, options);\n    /**\n     * The stream returned by the provider cannot work with an asynchronous iterator.\n     * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.\n     * This affects performance (+25%). I don't see best solution right now.\n     */\n\n    return utils.stream.merge(works);\n  }\n\n  FastGlob.stream = stream;\n\n  function generateTasks(source, options) {\n    assertPatternsInput(source);\n    var patterns = patternManager.transform([].concat(source));\n    var settings = new settings_1.default(options);\n    return taskManager.generate(patterns, settings);\n  }\n\n  FastGlob.generateTasks = generateTasks;\n\n  function isDynamicPattern(source, options) {\n    assertPatternsInput(source);\n    var settings = new settings_1.default(options);\n    return utils.pattern.isDynamicPattern(source, settings);\n  }\n\n  FastGlob.isDynamicPattern = isDynamicPattern;\n\n  function escapePath(source) {\n    assertPatternsInput(source);\n    return utils.path.escape(source);\n  }\n\n  FastGlob.escapePath = escapePath;\n})(FastGlob || (FastGlob = {}));\n\nfunction getWorks(source, _Provider, options) {\n  var patterns = patternManager.transform([].concat(source));\n  var settings = new settings_1.default(options);\n  var tasks = taskManager.generate(patterns, settings);\n  var provider = new _Provider(settings);\n  return tasks.map(provider.read, provider);\n}\n\nfunction assertPatternsInput(input) {\n  var source = [].concat(input);\n  var isValidSource = source.every(function (item) {\n    return utils.string.isString(item) && !utils.string.isEmpty(item);\n  });\n\n  if (!isValidSource) {\n    throw new TypeError('Patterns must be a string (non empty) or an array of strings');\n  }\n}\n\nmodule.exports = FastGlob;","map":null,"metadata":{},"sourceType":"script"}