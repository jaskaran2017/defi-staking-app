{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\n\nvar path = require(\"path\");\n\nvar globParent = require(\"glob-parent\");\n\nvar micromatch = require(\"micromatch\");\n\nvar GLOBSTAR = '**';\nvar ESCAPE_SYMBOL = '\\\\';\nvar COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\nvar REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\nvar REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\nvar GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\nvar BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\n\nfunction isStaticPattern(pattern) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return !isDynamicPattern(pattern, options);\n}\n\nexports.isStaticPattern = isStaticPattern;\n\nfunction isDynamicPattern(pattern) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /**\n   * A special case with an empty string is necessary for matching patterns that start with a forward slash.\n   * An empty string cannot be a dynamic pattern.\n   * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\n   */\n  if (pattern === '') {\n    return false;\n  }\n  /**\n   * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\n   * filepath directly (without read directory).\n   */\n\n\n  if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n    return true;\n  }\n\n  if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n\n  if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n\n  if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.isDynamicPattern = isDynamicPattern;\n\nfunction hasBraceExpansion(pattern) {\n  var openingBraceIndex = pattern.indexOf('{');\n\n  if (openingBraceIndex === -1) {\n    return false;\n  }\n\n  var closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);\n\n  if (closingBraceIndex === -1) {\n    return false;\n  }\n\n  var braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\n  return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\n}\n\nfunction convertToPositivePattern(pattern) {\n  return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\n\nexports.convertToPositivePattern = convertToPositivePattern;\n\nfunction convertToNegativePattern(pattern) {\n  return '!' + pattern;\n}\n\nexports.convertToNegativePattern = convertToNegativePattern;\n\nfunction isNegativePattern(pattern) {\n  return pattern.startsWith('!') && pattern[1] !== '(';\n}\n\nexports.isNegativePattern = isNegativePattern;\n\nfunction isPositivePattern(pattern) {\n  return !isNegativePattern(pattern);\n}\n\nexports.isPositivePattern = isPositivePattern;\n\nfunction getNegativePatterns(patterns) {\n  return patterns.filter(isNegativePattern);\n}\n\nexports.getNegativePatterns = getNegativePatterns;\n\nfunction getPositivePatterns(patterns) {\n  return patterns.filter(isPositivePattern);\n}\n\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Returns patterns that can be applied inside the current directory.\n *\n * @example\n * // ['./*', '*', 'a/*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\n\nfunction getPatternsInsideCurrentDirectory(patterns) {\n  return patterns.filter(function (pattern) {\n    return !isPatternRelatedToParentDirectory(pattern);\n  });\n}\n\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n/**\n * Returns patterns to be expanded relative to (outside) the current directory.\n *\n * @example\n * // ['../*', './../*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\n\nfunction getPatternsOutsideCurrentDirectory(patterns) {\n  return patterns.filter(isPatternRelatedToParentDirectory);\n}\n\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\n\nfunction isPatternRelatedToParentDirectory(pattern) {\n  return pattern.startsWith('..') || pattern.startsWith('./..');\n}\n\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\n\nfunction getBaseDirectory(pattern) {\n  return globParent(pattern, {\n    flipBackslashes: false\n  });\n}\n\nexports.getBaseDirectory = getBaseDirectory;\n\nfunction hasGlobStar(pattern) {\n  return pattern.includes(GLOBSTAR);\n}\n\nexports.hasGlobStar = hasGlobStar;\n\nfunction endsWithSlashGlobStar(pattern) {\n  return pattern.endsWith('/' + GLOBSTAR);\n}\n\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\n\nfunction isAffectDepthOfReadingPattern(pattern) {\n  var basename = path.basename(pattern);\n  return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\n\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\n\nfunction expandPatternsWithBraceExpansion(patterns) {\n  return patterns.reduce(function (collection, pattern) {\n    return collection.concat(expandBraceExpansion(pattern));\n  }, []);\n}\n\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\n\nfunction expandBraceExpansion(pattern) {\n  return micromatch.braces(pattern, {\n    expand: true,\n    nodupes: true\n  });\n}\n\nexports.expandBraceExpansion = expandBraceExpansion;\n\nfunction getPatternParts(pattern, options) {\n  var _micromatch$scan = micromatch.scan(pattern, Object.assign(Object.assign({}, options), {\n    parts: true\n  })),\n      parts = _micromatch$scan.parts;\n  /**\n   * The scan method returns an empty array in some cases.\n   * See micromatch/picomatch#58 for more details.\n   */\n\n\n  if (parts.length === 0) {\n    parts = [pattern];\n  }\n  /**\n   * The scan method does not return an empty part for the pattern with a forward slash.\n   * This is another part of micromatch/picomatch#58.\n   */\n\n\n  if (parts[0].startsWith('/')) {\n    parts[0] = parts[0].slice(1);\n    parts.unshift('');\n  }\n\n  return parts;\n}\n\nexports.getPatternParts = getPatternParts;\n\nfunction makeRe(pattern, options) {\n  return micromatch.makeRe(pattern, options);\n}\n\nexports.makeRe = makeRe;\n\nfunction convertPatternsToRe(patterns, options) {\n  return patterns.map(function (pattern) {\n    return makeRe(pattern, options);\n  });\n}\n\nexports.convertPatternsToRe = convertPatternsToRe;\n\nfunction matchAny(entry, patternsRe) {\n  return patternsRe.some(function (patternRe) {\n    return patternRe.test(entry);\n  });\n}\n\nexports.matchAny = matchAny;","map":null,"metadata":{},"sourceType":"script"}